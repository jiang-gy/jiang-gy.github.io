<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>论文写作</title>
      <link href="/2024/01/27/lun-wen-xie-zuo/lun-wen-xie-zuo/"/>
      <url>/2024/01/27/lun-wen-xie-zuo/lun-wen-xie-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h1><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><h3 id="1-写作方法"><a href="#1-写作方法" class="headerlink" title="1 写作方法"></a>1 写作方法</h3><blockquote><p>  以下内容来源于ChatGPT</p></blockquote><p>科技论文中的结果分析部分是非常关键的，它不仅仅是简单地<strong>陈述实验结果</strong>，更要<strong>深入剖析数据</strong>，<strong>解释观察到的现象</strong>，并将<strong>结果与研究问题或假设联系起来</strong>。以下是一个通用的科技论文结果分析部分的写作指南：</p><ol><li><strong>清晰陈述结果</strong>：<ul><li>在开始结果分析之前，先提供一个简明扼要的结果总结。</li><li>使用图表、表格和统计数据以清晰的方式呈现主要实验结果。</li></ul></li><li><strong>数据的准确性</strong>：<ul><li>强调实验数据的准确性和可靠性。讨论任何可能的偏差或误差来源，并解释你采取的措施来控制这些因素。</li></ul></li><li><strong>与文献和假设的关系</strong>：<ul><li>将你的实验结果与之前的研究和文献进行比较。讨论你的结果是否与先前的研究一致，或者是否存在差异。</li><li>检验你的实验结果是否支持或反驳了最初的研究假设。</li></ul></li><li><strong>趋势和模式</strong>：<ul><li>分析数据中的趋势和模式。有没有明显的关联或相互关系？这些趋势是否与你的研究问题相关？</li></ul></li><li><strong>统计分析</strong>：<ul><li>如果进行了统计分析，解释所使用的统计测试方法，例如 t 检验、方差分析等。提供 p 值，并讨论结果的显著性。</li><li>注意，不要仅仅陈述 p 值，而是解释它们的意义。</li></ul></li><li><strong>异常值和离群值</strong>：<ul><li>如果有异常值或离群值，解释它们的存在，并讨论它们是否对结果产生了重大影响。</li></ul></li><li><strong>影响因素</strong>：<ul><li>讨论任何可能影响结果的因素。这可能包括实验设计、样本大小、实验条件等。</li></ul></li><li><strong>局限性</strong>：<ul><li>诚实地讨论研究的局限性。指出研究可能存在的缺陷，以及对结果解释的限制。</li></ul></li><li><strong>未来工作</strong>：<ul><li>提出未来的研究方向。根据你的结果，探讨下一步应该采取的研究方向，以填补现有知识的空白。</li></ul></li><li><strong>清晰的结论</strong>：</li></ol><ul><li>总结结果分析，强调对研究问题的回答，论文的主要发现，以及这些发现的重要性。</li></ul><p>确保结果分析部分具有逻辑结构，清晰地展示你对实验结果的深刻理解和分析。在整个部分中使用专业术语，但确保解释清楚以便读者理解。</p><h3 id="1-例子"><a href="#1-例子" class="headerlink" title="1 例子"></a>1 例子</h3><ol><li><strong>以刘勇毕业论文为例：</strong></li></ol><p>在这一部分中，本章对不同拓扑下各种算法的性能比较进行了分析和讨论。如图 3.5 所示，本章对不同算法下的控制器资源利用率进行了测试。在不同网络拓扑下，随着流量负载的增加，TSMM算法的控制器资源利用率总是维持在0.7以上。相比于传统的启发式算法NSGA-II 和OPA算法，TSMM算法有较高的网络性能。由于传统的启发式算法没有考虑控制器负载的约束，因此这会造成多个控制器之间资源的不合理分配。在NSFNET拓扑下，当流量负载为60时，相比于CCPP算法，TSMM算法的控制器资源利用率提高了35*.<em>6%；同时在OS3E 拓扑下，其提高了48</em>.*9%的控制器资源利用率。另外，在Ta2和Interoute拓扑下，相比于CCPP算法，TSMM算法的资源利用率至少提高了40%。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202401271720778.png" alt="image-20240127172015669"></p><p>解析：</p><ol><li></li></ol><p>对于平均时延的性能比较，如图 3.6 所示。在不同拓扑下，随着流量负载的增加，平均时延也逐渐递增。相比于传统的启发式算法NSGA-II 和OPA算法，在流量负载为60时，TSMM有较好的时延性能（至少20%）。因为在实际执行过程中，TSMM算法对控制器和交换机之间的传输时延进行了优化，因此它能消减平均时延。在NSFNET和OS3E拓扑下，当流量负载为60时，相比于启发式CCPP算法，TSMM算</p><p>法分别消减了17*.<em>5%和21</em>.<em>3%的平均时延。同时，对于Ta2和Interoute拓扑，TSMM算法分别消减了6</em>.<em>5%和9</em>.*8%的平均时延。如图 3.7 所示，本章对控制器的负载均衡性能进行了测试。在不同网络拓扑</p><p>下，随着流量负载的增加，TSMM算法的负载均衡度总是维持在0.4以下。相比于其它三种传统的启发式算法，TSMM算法有较好的性能。相比于NSGA-II和OPA算法，TSMM算法的负载均衡性能平均提高了40%左右。在NSFNET拓扑下，当流量负载为150时，相比于CCPP算法，TSMM算法提高了31*.<em>6%的负载均衡性能；且在OS3E拓扑下，其提高了33</em>.*5%的负载均衡性能。在Ta2和Interoute拓扑下，相比于CCPP算法，TSMM算法提高了至少20%的负载均衡性能。因为，在控制器部署过程中，TSMM算法考虑对多个性能指标进行优化，并通过交换机迁移方法实现控制器负载的均衡分布。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202401271722781.png" alt="image-20240127172158577"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex使用方式</title>
      <link href="/2024/01/26/latex/latex-yu-fa/"/>
      <url>/2024/01/26/latex/latex-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Latex使用方式"><a href="#Latex使用方式" class="headerlink" title="Latex使用方式"></a>Latex使用方式</h1><h2 id="1-Latex优势"><a href="#1-Latex优势" class="headerlink" title="1 Latex优势"></a>1 Latex优势</h2><ul><li>使用固定模板，格式固定，只需套用模板即可生成文章</li></ul><h2 id="2-Latex图表"><a href="#2-Latex图表" class="headerlink" title="2 Latex图表"></a>2 Latex图表</h2><h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1. 表格"></a>1. 表格</h3><ol><li><strong>设定表格宽度</strong><a href="%5BLatex%E8%A7%A3%E5%86%B3%E8%A1%A8%E6%A0%BC%E8%BF%87%E5%AE%BD%E9%97%AE%E9%A2%98%EF%BC%8C%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E6%95%B4%E5%AE%BD%E5%BA%A6%5D(https://zhuanlan.zhihu.com/p/337457317)">^1</a></li></ol><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex"><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">graphicx</span><span class="token punctuation">}</span> # 记得加宏包<span class="token function selector">\resizebox</span><span class="token punctuation">{</span><span class="token function selector">\linewidth</span><span class="token punctuation">}</span><span class="token punctuation">{</span>!<span class="token punctuation">}</span><span class="token punctuation">{</span>  #此处！表示根据根据宽高比进行自适应缩放<span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span>...........<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">}</span> # 注意加的位置在<span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span>和<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span>前后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>文字自动换行</p><p>还在研究中，相关链接<a href="%5Blatex%E8%A1%A8%E6%A0%BC%E4%B8%AD%E5%86%85%E5%AE%B9%E8%BF%87%E5%A4%9A%E5%A6%82%E4%BD%95%E6%8D%A2%E8%A1%8C%E3%80%90%E5%B7%B2%E8%A7%A3%E5%86%B3%E3%80%91%5D(https://blog.csdn.net/qq_43604183/article/details/134739083?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-134739083-blog-121678328.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-134739083-blog-121678328.235%5Ev43%5Epc_blog_bottom_relevance_base3)">^2</a></p></li></ol><h3 id="2-图片"><a href="#2-图片" class="headerlink" title="2. 图片"></a>2. 图片</h3><ol><li>单栏与双栏图片<a href="%5BLatex%E5%86%99%E6%96%87%E7%AB%A0%E6%97%B6%E6%8F%92%E5%85%A5%E5%8D%95%E6%A0%8F%E5%9B%BE%E7%89%87%E5%92%8C%E5%8F%8C%E6%A0%8F%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95%5D(https://blog.csdn.net/Time_Memory_cici/article/details/129381838)">^4</a></li></ol><p>单栏</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span>...<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>双栏</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span>...<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My New Post</title>
      <link href="/2024/01/21/my-new-post/"/>
      <url>/2024/01/21/my-new-post/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>行楷注意事项</title>
      <link href="/2024/01/21/shu-fa/xie-zi-zhu-yi-dian/"/>
      <url>/2024/01/21/shu-fa/xie-zi-zhu-yi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="行楷注意事项"><a href="#行楷注意事项" class="headerlink" title="行楷注意事项"></a>行楷注意事项</h1><h2 id="1-手指发力"><a href="#1-手指发力" class="headerlink" title="1. 手指发力"></a>1. 手指发力</h2><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202401211523108.webp" alt="img"></p><p>先调整坐姿：双脚落地，上身保持挺直，略微前倾，以便观察字的布局；头部端正，保证视线的角度不发生偏移。</p><p><strong>轻松握笔，不要太用力。手腕呈自然直线状态，切忌内弯。</strong></p><p>书写本稍微左倾，这个角度多大合适呢？和地轴倾斜的角度保持差不多大小是符合人挺工程学的，这个角度准确数字是23.26°，那么我们本子的倾斜角度在10°-30°之间是合适的，这符合人与自然和谐统一的大规则，太直了写字久了容易累，角度太大容易造成身体前倾，会影响脊椎发育。</p><p><strong>手指、手腕发力点详解：</strong></p><p>此时手腕应该是外侧贴于纸面，保持一个舒展的姿态，同样根据自己的舒适度灵活调整。</p><p><strong>横的发力点在手腕</strong>，主要靠手腕摆动，手部四个触笔点保持被动受力带动笔运动，水平摆腕写出横。</p><p><strong>竖的发力点主要在食指</strong>，食指指尖下推笔杆，拇指指尖轻触笔杆，拇指关节弯曲迎接食指下推力，中指触笔点抵住笔杆向下配合食指推力，让笔保持直线下行。</p><p><strong>捺的发力点是拇指、食指指尖同时向右下发力</strong>，逐渐加重用力，至捺末端，改变方向向右平出。</p><p><strong>提的发力点在中指</strong>，中指第一关节触笔点向右上推动笔杆，拇指关节由曲变伸、食指配合向上，长提要有腕部发力来配合。</p><p>注意到无论哪种形式，大拇指均未发力，只起到方向的作用。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/163566330#:~:text=%E6%A8%AA%E7%9A%84%E5%8F%91%E5%8A%9B%E7%82%B9%E5%9C%A8%E6%89%8B%E8%85%95%20%EF%BC%8C%E4%B8%BB%E8%A6%81%E9%9D%A0%E6%89%8B%E8%85%95%E6%91%86%E5%8A%A8%EF%BC%8C%E6%89%8B%E9%83%A8%E5%9B%9B%E4%B8%AA%E8%A7%A6%E7%AC%94%E7%82%B9%E4%BF%9D%E6%8C%81%E8%A2%AB%E5%8A%A8%E5%8F%97%E5%8A%9B%E5%B8%A6%E5%8A%A8%E7%AC%94%E8%BF%90%E5%8A%A8%EF%BC%8C%E6%B0%B4%E5%B9%B3%E6%91%86%E8%85%95%E5%86%99%E5%87%BA%E6%A8%AA%E3%80%82%20%E7%AB%96%E7%9A%84%E5%8F%91%E5%8A%9B%E7%82%B9%E4%B8%BB%E8%A6%81%E5%9C%A8%E9%A3%9F%E6%8C%87,%EF%BC%8C%E9%A3%9F%E6%8C%87%E6%8C%87%E5%B0%96%E4%B8%8B%E6%8E%A8%E7%AC%94%E6%9D%86%EF%BC%8C%E6%8B%87%E6%8C%87%E6%8C%87%E5%B0%96%E8%BD%BB%E8%A7%A6%E7%AC%94%E6%9D%86%EF%BC%8C%E6%8B%87%E6%8C%87%E5%85%B3%E8%8A%82%E5%BC%AF%E6%9B%B2%E8%BF%8E%E6%8E%A5%E9%A3%9F%E6%8C%87%E4%B8%8B%E6%8E%A8%E5%8A%9B%EF%BC%8C%E4%B8%AD%E6%8C%87%E8%A7%A6%E7%AC%94%E7%82%B9%E6%8A%B5%E4%BD%8F%E7%AC%94%E6%9D%86%E5%90%91%E4%B8%8B%E9%85%8D%E5%90%88%E9%A3%9F%E6%8C%87%E6%8E%A8%E5%8A%9B%EF%BC%8C%E8%AE%A9%E7%AC%94%E4%BF%9D%E6%8C%81%E7%9B%B4%E7%BA%BF%E4%B8%8B%E8%A1%8C%E3%80%82%20%E6%8D%BA%E7%9A%84%E5%8F%91%E5%8A%9B%E7%82%B9%E6%98%AF%E6%8B%87%E6%8C%87%E3%80%81%E9%A3%9F%E6%8C%87%E6%8C%87%E5%B0%96%E5%90%8C%E6%97%B6%E5%90%91%E5%8F%B3%E4%B8%8B%E5%8F%91%E5%8A%9B%20%EF%BC%8C%E9%80%90%E6%B8%90%E5%8A%A0%E9%87%8D%E7%94%A8%E5%8A%9B%EF%BC%8C%E8%87%B3%E6%8D%BA%E6%9C%AB%E7%AB%AF%EF%BC%8C%E6%94%B9%E5%8F%98%E6%96%B9%E5%90%91%E5%90%91%E5%8F%B3%E5%B9%B3%E5%87%BA%E3%80%82">知乎</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 书法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2024/01/21/markdown/markdown-yu-fa/"/>
      <url>/2024/01/21/markdown/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="1-Markdown优势"><a href="#1-Markdown优势" class="headerlink" title="1 Markdown优势"></a>1 Markdown优势</h2><ul><li>相对于word，操作方便，打开迅速</li><li>主题丰富，较为美观</li></ul><h2 id="2-Markdown语法"><a href="#2-Markdown语法" class="headerlink" title="2 Markdown语法"></a>2 Markdown语法</h2><h3 id="1-脚注，尾注"><a href="#1-脚注，尾注" class="headerlink" title="1 脚注，尾注"></a>1 脚注，尾注</h3><p>参考文章[^1]</p><p><strong>1.脚注，尾注</strong>：主要用于注释说明内容 (参看<a href="https://link.zhihu.com/?target=https://www.imooc.com/wiki/markdownlesson/markdownfootnote.html%23:~:text=%E5%86%99%E5%88%B0%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E3%80%82-,3.%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E4%BE%8B,-%E5%AE%9E%E4%BE%8B%204%EF%BC%9A">使用场景</a>)。脚注/尾注的特点是可以在页面中来回跳转。</p><p>示例：</p><p>这是一个链接到谷歌的<a href="http://www.google.com/">^脚注</a>。</p><p>源码：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">这是一个链接到谷歌的[^脚注]。[^脚注]: http://www.google.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202401211224018.webp" alt="img"></p><h3 id="2-引用链接"><a href="#2-引用链接" class="headerlink" title="2 引用链接"></a>2 引用链接</h3><p>两部分：</p><ul><li>引用文本</li><li>引用主体</li></ul><p>引用文本格式：<code>[显示文字][引用标签]</code></p><p>引用主体格式：<code>[引用标签]: &lt;链接地址&gt; (链接可选标题)</code>(参看主体格式说明<a href="https://zhuanlan.zhihu.com/p/499137261/%E4%BB%A5%E4%B8%8B%E7%A4%BA%E4%BE%8B%E6%A0%BC%E5%BC%8F%E5%AF%B9%E4%BA%8E**%E5%BC%95%E7%94%A8%E4%B8%BB%E4%BD%93%E6%A0%BC%E5%BC%8F**%E6%95%88%E6%9E%9C%E7%9B%B8%E5%90%8C%EF%BC%9A">^1</a>)</p><p>示例：</p><p>I get 10 times more traffic from <a href="http://google.com/" title="Google">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search">MSN</a>.  </p><p>一般链接放置位置末尾，便于统一管理。</p><p>源码：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].  [1]: http://google.com/        "Google" [2]: http://search.yahoo.com/  "Yahoo Search" [3]: http://search.msn.com/    "MSN Search"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[^1]:<a href="https://zhuanlan.zhihu.com/p/499137261">Markdown写作 | 尾注,脚注和引用链接的正确使用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
            <tag> Markdown语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2024/01/21/bo-ke/bo-ke-da-jian/"/>
      <url>/2024/01/21/bo-ke/bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo笔记搭建记录文档"><a href="#Hexo笔记搭建记录文档" class="headerlink" title="Hexo笔记搭建记录文档"></a>Hexo笔记搭建记录文档</h1><h2 id="一-Hexo网站的优势"><a href="#一-Hexo网站的优势" class="headerlink" title="一 Hexo网站的优势"></a>一 Hexo网站的优势</h2><p>博客平台如CSDN，博客园，简书等平台，用户可以直接在上面发表，缺点是比较不自由，会受到平台的各种限制和恶心的广告。</p><p>购买域名和服务器成本太高了，花力气去自己搭这么一个网站，还要定期的维护它，成本精力较大。</p><p>那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。</p><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h2 id="二-环境配置"><a href="#二-环境配置" class="headerlink" title="二 环境配置"></a>二 环境配置</h2><p>参考链接<a href="%5B%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/sinat_37781304/article/details/82729029?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168845286916800222814197%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168845286916800222814197&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82729029-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=hexo&amp;spm=1018.2226.3001.4449)">^1</a></p><p>常见命令</p><ol><li>Create a new post</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><ol start="2"><li>Run server</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><ol start="3"><li>Generate static files</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><ol start="4"><li>Deploy to remote sites</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三-文章加密"><a href="#三-文章加密" class="headerlink" title="三 文章加密"></a>三 文章加密</h2><p>有些文章需要设置为私密，此时需要为文章添加密码。[^3]</p><ol><li>安装插件hexo-blog-encrypt：</li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">npm install –save hexo-blog-encrypt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><p>然后在hexo全局配置文件_config.yml 中启用该插件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Security</span><span class="token key atrule">encrypt</span><span class="token punctuation">:</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在需要加密的文章头部添加所要求的字段，如：password，abstract，message等。</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---title: 文章加密date: <span class="token number">2020</span>-06-04 <span class="token number">9</span>:46:03password: 程序员在旅途abstract: 这是一篇加密博文，请输入密码后查看message: 这里需要密码才能访问。wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="* 常见问题"></a>* 常见问题</h2><h3 id="1-npm下载报错npm-ERR-code-ETIMEDOUT-npm-ERR"><a href="#1-npm下载报错npm-ERR-code-ETIMEDOUT-npm-ERR" class="headerlink" title="1. npm下载报错npm ERR! code ETIMEDOUT npm ERR!"></a>1. npm下载报错npm ERR! code ETIMEDOUT npm ERR!</h3><p>主要是网络配置问题[^2]</p><ol><li>查看npm镜像设置</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">npm config <span class="token keyword">get</span> registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>将npm设置为淘宝镜像</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">npm config <span class="token keyword">set</span> registry https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>再次查看npm镜像设置</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">npm config <span class="token keyword">get</span> registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[^2]:<a href="https://blog.csdn.net/m0_46695182/article/details/127846670">npm下载报错npm ERR!</a><br>[^3]: <a href="https://blog.csdn.net/qq_24754061/article/details/106569222">Hexo博文加密思路总结</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
            <tag> Markdown语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQN笔记</title>
      <link href="/2023/07/21/dqn-bi-ji/dqn-bi-ji/"/>
      <url>/2023/07/21/dqn-bi-ji/dqn-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h1><p>DQN两个因素</p><p> DQN 有一个记忆库用于学习之前的经历. 在之前的简介影片中提到过, Q learning 是一种 off-policy 离线学习法, 它能学习当前经历着的, 也能学习过去经历过的, 甚至是学习别人的经历. 所以每次 DQN 更新的时候, 我们都可以随机抽取一些之前的经历进行学习. 随机抽取这种做法打乱了经历之间的相关性, 也使得神经网络更新更有效率. Fixed Q-targets 也是一种打乱相关性的机理, 如果使用 fixed Q-targets, 我们就会在 DQN 中使用到两个结构相同但参数不同的神经网络, 预测 Q 估计 的神经网络具备最新的参数, 而预测 Q 现实 的神经网络使用的参数则是很久以前的. 有了这两种提升手段, DQN 才能在一些游戏中超越人类.</p><h2 id="2-程序运行"><a href="#2-程序运行" class="headerlink" title="2. 程序运行"></a>2. 程序运行</h2><p>安装TensorFlow</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> <span class="token assign-left variable">tensorflow</span><span class="token operator">==</span><span class="token number">1.0</span>.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将脚本中<code>output_graph=True</code>设置后</p><p>运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tensorboard <span class="token parameter variable">--logdir</span><span class="token operator">=</span>logs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用手册</title>
      <link href="/2023/07/21/git-shi-yong-shou-ce/"/>
      <url>/2023/07/21/git-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><p>Linux</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WIndows</p><p>“Git”-&gt;“Git Bash”</p><h3 id="1-1-配置"><a href="#1-1-配置" class="headerlink" title="1.1 配置"></a>1.1 配置</h3><p>分布式版本控制，所有机器自报家门</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"Your Name"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="1-2-私有数据库下载权限设置"><a href="#1-2-私有数据库下载权限设置" class="headerlink" title="1.2 私有数据库下载权限设置"></a>1.2 私有数据库下载权限设置</h3><p>如果需要下载私有仓库内容，需要将SSH添加至远程库中，获取相应权限后，方可克隆文件。</p><p>你可以按如下命令来生成 sshkey:</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t ed25519 -C "xxxxx@xxxxx.com"  # Generating public/private ed25519 key pair...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意：这里的 <code>xxxxx@xxxxx.com</code> 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱。<br>现网的大部分教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱。</p></blockquote><p>按照提示完成三次回车，即可生成 ssh key。通过查看 <code>~/.ssh/id_ed25519.pub</code> 文件内容，获取到你的 public key</p><blockquote><p>注意:</p><p>不同的電腦公钥的位置可能不同。公钥所在的位置根据在生成公钥的命令行提示内容处获取【见下图】</p></blockquote><pre class="line-numbers language-none"><code class="language-none">cat ~/.ssh/id_ed25519.pub# ssh-ed25519 AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537110.png" alt="SSH生成"></p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537112.png" alt="image-20220630163316806"></p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537113.png" alt="输入图片说明"></p><p>复制生成后的 ssh key，通过仓库主页 <strong>「管理」-&gt;「部署公钥管理」-&gt;「添加部署公钥」</strong> ，添加生成的 public key 添加到仓库中。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537114.png" alt="添加部署公钥"></p><p>添加后，在终端（Terminal）中输入</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@gitee.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首次使用需要确认并添加主机到本机SSH可信列表。若返回 <code>Hi XXX! You've successfully authenticated, but Gitee.com does not provide shell access.</code> 内容，则证明添加成功。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537115.png" alt="SSH添加提示"></p><p>添加成功后，就可以使用SSH协议对仓库进行操作了。</p><h3 id="1-3-仓库公钥和可部署公钥"><a href="#1-3-仓库公钥和可部署公钥" class="headerlink" title="1.3 仓库公钥和可部署公钥"></a>1.3 仓库公钥和可部署公钥</h3><p>为了便于用户在多个项目仓库下使用一套公钥，免于重复部署和管理的繁琐，Gitee 推出了「可部署公钥」功能，支持在一个仓库空间下使用当前账户名下/参与的另一个仓库空间的部署公钥，实现公钥共用。</p><h3 id="1-4-个人公钥"><a href="#1-4-个人公钥" class="headerlink" title="1.4 个人公钥"></a>1.4 个人公钥</h3><p>添加个人公钥后，对于所有的仓库都有读写权限。</p><h2 id="二-版本库"><a href="#二-版本库" class="headerlink" title="二 版本库"></a>二 版本库</h2><p>版本库又名仓库，英文名<strong>repository</strong>。可以简单理解成一个目录。</p><p>Git仓库表示该目录下所有文件都被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><ol><li>创建空目录</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> learngit<span class="token builtin class-name">cd</span> learngit<span class="token builtin class-name">pwd</span>/Users/michael/learngit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文</p></blockquote><ol start="2"><li>将目录变为Git可管理的仓库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> initInitialized empty Git repository <span class="token keyword">in</span> /Users/michael/learngit/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完成创建。</p><p>其中，初始化后目录下增加<code>.git</code>目录。该目录用于跟踪管理版本库的。千万不能修改</p><ol start="3"><li><p>文件添加至版本库</p><blockquote><p>所有版本控制系统，只能跟踪文件的改动，比如TXT、网页、程序代码</p><p>图片、视频二进制文件无法追踪文件变化。其中Word也是二进制格式。</p></blockquote><p>其中，文件添加至版本库分两步：添加与提交</p><ol><li>用命令<code>git add</code>告诉Git，把文件添加到仓库：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>用命令<code>git commit</code>告诉Git，把文件提交到仓库：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"wrote a readme file"</span><span class="token punctuation">[</span>master <span class="token punctuation">(</span>root-commit<span class="token punctuation">)</span> eaadf4e<span class="token punctuation">]</span> wrote a readme <span class="token function">file</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，用于从历史记录里方便地找到改动记录。</p><p>也可以不输入<code>-m "xxx"</code>，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p><strong>分为两步的原因</strong></p><p>add添加可以每次添加不同的文件，根据自己改的文件进行添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> file1.txt$ <span class="token function">git</span> <span class="token function">add</span> file2.txt file3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>commit一次提交所有更改文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add 3 files."</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="三-版本回退"><a href="#三-版本回退" class="headerlink" title="三 版本回退"></a>三 版本回退</h2><h3 id="3-1-相关操作"><a href="#3-1-相关操作" class="headerlink" title="3.1 相关操作"></a>3.1 相关操作</h3><ol><li><p>随时查看仓库状态</p><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态</p><p>若修改readme.txt文件，改成如下内容：</p><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，运行<code>git status</code>命令看看结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p></li><li><p>查看修改内容</p><p>如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> readme.txt <span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txtindex 46d49bf<span class="token punctuation">..</span>9247db6 <span class="token number">100644</span>--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@<span class="token parameter variable">-Git</span> is a version control system.+Git is a distributed version control system. Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>提交修改</p><p>同样为添加与提交两步</p><p>第一步是<code>git add</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code>显示：将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add distributed"</span><span class="token punctuation">[</span>master e475afc<span class="token punctuation">]</span> <span class="token function">add</span> distributed <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p></li></ol><h3 id="3-2-版本快照"><a href="#3-2-版本快照" class="headerlink" title="3.2 版本快照"></a>3.2 版本快照</h3><p>类似游戏的手动存盘。每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。</p><p>快照的作用为：一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>版本1：wrote a readme file</p><pre class="line-numbers language-none"><code class="language-none">Git is a version control system.Git is free software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本2：add distributed</p><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本3：append GPL</p><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="查看之间快照"><a href="#查看之间快照" class="headerlink" title="查看之间快照"></a>查看之间快照</h5><p>在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，</p><p>在Git中，我们可用<code>git log</code>命令查看修改历史记录，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:06:15 <span class="token number">2018</span> +0800    append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:03:36 <span class="token number">2018</span> +0800    <span class="token function">add</span> distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">20</span>:59:18 <span class="token number">2018</span> +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> append GPLe475afc93c209a690c39c13a46716e8fa000c366 <span class="token function">add</span> distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>前面一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）。</p><p>Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><p>为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。</p><h5 id="回退快照"><a href="#回退快照" class="headerlink" title="回退快照"></a>回退快照</h5><p>  我们准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><ol><li>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</li><li>把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD^HEAD is now at e475afc <span class="token function">add</span> distributed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>果然被还原了。</p><p>让我们用<code>git log</code>再看看现在版本库的状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> logcommit e475afc93c209a690c39c13a46716e8fa000c366 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:03:36 <span class="token number">2018</span> +0800    <span class="token function">add</span> distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">20</span>:59:18 <span class="token number">2018</span> +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>在未关闭命令行界面的情况下，回到最新的版本</li></ol><p>查看log发现最新的那个版本<code>append GPL</code>已经看不到了！但如何回到最新状态？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> 1094aHEAD is now at 83b0afe append GPL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><pre class="line-numbers language-none"><code class="language-none">$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   └──&gt; ○ append GPL        │        ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改为指向<code>add distributed</code>：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   │    ○ append GPL   │    │   └──&gt; ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><ol start="4"><li><p>在关闭命令行界面的情况下，回到最新的版本：使用 <code>git reflog</code></p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，当用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。</p><p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> refloge475afc HEAD@<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>: reset: moving to HEAD^1094adb <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>: commit: append GPLe475afc HEAD@<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span>: commit: <span class="token function">add</span> distributedeaadf4e HEAD@<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span>: commit <span class="token punctuation">(</span>initial<span class="token punctuation">)</span>: wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>。</p><h3 id="3-3-Git修改文件原理"><a href="#3-3-Git修改文件原理" class="headerlink" title="3.3 Git修改文件原理"></a>3.3 Git修改文件原理</h3><h4 id="1-工作区（Working-Directory）"><a href="#1-工作区（Working-Directory）" class="headerlink" title="1. 工作区（Working Directory）"></a>1. 工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537116.png" alt="working-dir"></p><h4 id="2-版本库（Repository）"><a href="#2-版本库（Repository）" class="headerlink" title="2. 版本库（Repository）"></a>2. 版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西。</p><p>其中最重要的就是称为stage（或者叫index）的暂存区。</p><p>还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><h4 id="Git分区示意图"><a href="#Git分区示意图" class="headerlink" title="Git分区示意图"></a>Git分区示意图</h4><p>Git主要可以分为工作区、暂存区与分支。其中暂存区与分支存放在版本库中。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537117.jpeg" alt="git-repo"></p><h4 id="具体联系"><a href="#具体联系" class="headerlink" title="具体联系"></a>具体联系</h4><p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步<code>git add</code>：实际上就是把文件修改添加到暂存区；</p><p>第二步<code>git commit</code>：实际上就是把暂存区的所有内容提交到当前分支。</p><p>当我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支。所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>即两次过程为1.将需要提交的文件修改通通放到暂存区  2 .一次性提交暂存区的所有修改。</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><ol><li><p>工作区内容修改</p><p>先对<code>readme.txt</code>做个修改，比如加上一行内容：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtUntracked files:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>LICENSEno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><ol start="2"><li><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage）。</li></ol><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   LICENSEmodified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537118.jpeg" alt="git-stage"></p><ol start="3"><li>执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"understand how stage works"</span><span class="token punctuation">[</span>master e43a48b<span class="token punctuation">]</span> understand how stage works <span class="token number">2</span> files changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> LICENSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537119.jpeg" alt="git-stage-after-commit"></p><h4 id="Git管理原理"><a href="#Git管理原理" class="headerlink" title="Git管理原理"></a>Git管理原理</h4><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。其中，工作区存储文件，暂存区存储相应修改。即只修改工作区而不提交暂存区，Git将无法管理。</p><h5 id="什么是修改？"><a href="#什么是修改？" class="headerlink" title="什么是修改？"></a>什么是修改？</h5><p>比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改</p><h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><p>第一步，对readme.txt做一个修改，比如加一行内容：</p><pre class="line-numbers language-none"><code class="language-none">$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，添加：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt$ <span class="token function">git</span> status<span class="token comment"># On branch master</span><span class="token comment"># Changes to be committed:</span><span class="token comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span><span class="token comment">#</span><span class="token comment">#       modified:   readme.txt</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，再修改readme.txt：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txt Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时不将文件修改后内容放置暂存区，直接提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"git tracks changes"</span><span class="token punctuation">[</span>master 519219b<span class="token punctuation">]</span> <span class="token function">git</span> tracks changes <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，再看看状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们回顾一下操作过程：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code>。发现第二次的修改没有被提交？</p><p>原因为Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>最后，使用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> HEAD -- readme.txt <span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txtindex 76d770f<span class="token punctuation">..</span>a9c5755 <span class="token number">100644</span>--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is <span class="token function">free</span> software distributed under the GPL. Git has a mutable index called stage.<span class="token parameter variable">-Git</span> tracks changes.+Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那怎么提交第二次修改呢？</p><p>可以继续<code>git add</code>再<code>git commit</code>；</p><p>也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h5 id="情景1：丢弃工作区修改：git-checkout-–-file"><a href="#情景1：丢弃工作区修改：git-checkout-–-file" class="headerlink" title="情景1：丢弃工作区修改：git checkout – file"></a>情景1：丢弃工作区修改：git checkout – file</h5><p>想象场景，你在<code>readme.txt</code>中添加了一行：</p><pre class="line-numbers language-none"><code class="language-none">$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="丢弃修改"><a href="#丢弃修改" class="headerlink" title="丢弃修改"></a>丢弃修改</h6><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销。</p><p>这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><h5 id="情景2：丢弃暂存区修改：git-reset-HEAD-lt-file-gt"><a href="#情景2：丢弃暂存区修改：git-reset-HEAD-lt-file-gt" class="headerlink" title="情景2：丢弃暂存区修改：git reset HEAD <file>"></a>情景2：丢弃暂存区修改：git reset HEAD &lt;file&gt;</h5><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ <span class="token function">git</span> <span class="token function">add</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset HEAD readme.txtUnstaged changes after reset:Mreadme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还记得如何丢弃工作区的修改吗？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- readme.txt$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个世界终于清静了！</p><h5 id="情景3：丢弃本地分支修改：git-reset-HEAD-readme-txt"><a href="#情景3：丢弃本地分支修改：git-reset-HEAD-readme-txt" class="headerlink" title="情景3：丢弃本地分支修改：git reset HEAD readme.txt"></a>情景3：丢弃本地分支修改：git reset HEAD readme.txt</h5><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？</p><p>还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><h4 id="正常删除"><a href="#正常删除" class="headerlink" title="正常删除"></a>正常删除</h4><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> test.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add test.txt"</span><span class="token punctuation">[</span>master b84166e<span class="token punctuation">]</span> <span class="token function">add</span> test.txt <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add/rm &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>deleted:    test.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> test.txt<span class="token function">rm</span> <span class="token string">'test.txt'</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"remove test.txt"</span><span class="token punctuation">[</span>master d46f35e<span class="token punctuation">]</span> remove test.txt <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span> delete mode <span class="token number">100644</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，文件就从版本库中被删除了。</p><blockquote><p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</file></file></p></blockquote><h4 id="误删文件后恢复"><a href="#误删文件后恢复" class="headerlink" title="误删文件后恢复"></a>误删文件后恢复</h4><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的</p><h2 id="四-远程仓库"><a href="#四-远程仓库" class="headerlink" title="四 远程仓库"></a>四 远程仓库</h2><h3 id="4-1-远程仓库"><a href="#4-1-远程仓库" class="headerlink" title="4.1 远程仓库"></a>4.1 远程仓库</h3><p>远程仓库的作用是一方面防止本地硬盘损坏而导致项目代码丢失，另一方面方便多人对于同一工程文件的修改与完善。</p><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。</p><p>不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。</p><h4 id="1-设置Git秘钥"><a href="#1-设置Git秘钥" class="headerlink" title="1 设置Git秘钥"></a>1 设置Git秘钥</h4><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><p>第1步：创建SSH Key。</p><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537120.png" alt="github-addkey-1"></p><p>点“Add Key”，你就应该看到已经添加的Key：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537121.png" alt="github-addkey-2"></p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p><p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的操作。</p><h3 id="4-2-添加远程库"><a href="#4-2-添加远程库" class="headerlink" title="4.2 添加远程库"></a>4.2 添加远程库</h3><p>  你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p><h5 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1 步骤"></a>1 步骤</h5><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919021631860000/0" alt="github-create-repo-1"></p><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537122.png" alt="github-create-repo-2"></p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:michaelliao/learngit.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，==远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。==</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push <span class="token parameter variable">-u</span> origin masterCounting objects: <span class="token number">20</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">15</span>/15<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">20</span>/20<span class="token punctuation">)</span>, <span class="token number">1.64</span> KiB <span class="token operator">|</span> <span class="token number">560.00</span> KiB/s, done.Total <span class="token number">20</span> <span class="token punctuation">(</span>delta <span class="token number">5</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>remote: Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">5</span>/5<span class="token punctuation">)</span>, done.To github.com:michaelliao/learngit.git * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      master -<span class="token operator">&gt;</span> masterBranch <span class="token string">'master'</span> <span class="token builtin class-name">set</span> up to track remote branch <span class="token string">'master'</span> from <span class="token string">'origin'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537123.png" alt="github-repo"></p><p>从现在起，只要本地作了提交，就可以通过命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h4 id="2-SSH警告"><a href="#2-SSH警告" class="headerlink" title="2 SSH警告"></a>2 SSH警告</h4><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><pre class="line-numbers language-none"><code class="language-none">The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre class="line-numbers language-none"><code class="language-none">Warning: Permanently added 'github.com' (RSA) to the list of known hosts.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h3 id="4-3-删除远程库"><a href="#4-3-删除远程库" class="headerlink" title="4.3 删除远程库"></a>4.3 删除远程库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>origin  git@github.com:michaelliao/learn-git.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>origin  git@github.com:michaelliao/learn-git.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，根据名字删除，比如删除<code>origin</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token function">rm</span> origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h3 id="4-4-克隆远程库"><a href="#4-4-克隆远程库" class="headerlink" title="4.4 克隆远程库"></a>4.4 克隆远程库</h3><p>以上内容为先有本地库，后有远程库的时候，如何关联远程库。</p><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537124.png" alt="github-init-repo"></p><p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537125.png" alt="github-init-repo-2"></p><p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:michaelliao/gitskills.gitCloning into <span class="token string">'gitskills'</span><span class="token punctuation">..</span>.remote: Counting objects: <span class="token number">3</span>, done.remote: Total <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, pack-reused <span class="token number">3</span>Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">3</span>/3<span class="token punctuation">)</span>, done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> gitskills$ <span class="token function">ls</span>README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code></p><h2 id="五-分支管理"><a href="#五-分支管理" class="headerlink" title="五 分支管理"></a>五 分支管理</h2><h3 id="5-1分支管理"><a href="#5-1分支管理" class="headerlink" title="5.1分支管理"></a>5.1分支管理</h3><h4 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a>1 应用场景</h4><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537126.png" alt="learn-branches"></p><p>开发新功能但未完成。</p><p>立刻提交不完整的代码库导致别人无法继续工作</p><p>不提交存在丢失进度风险</p><h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2 解决方式"></a>2 解决方式</h4><p>建立自己分支，别人看不到。自己在自己分支工作。直至开发完毕后提交至原有分支</p><p>无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件</p><h3 id="5-2-创建合并分支"><a href="#5-2-创建合并分支" class="headerlink" title="5.2 创建合并分支"></a>5.2 创建合并分支</h3><h4 id="1-分支原理"><a href="#1-分支原理" class="headerlink" title="1 分支原理"></a>1 分支原理</h4><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。</p><p>截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。</p><p><code>HEAD</code>指向<code>master</code>，而<code>master</code>才是指向提交的。即<code>HEAD</code>指向的为当前分支。</p><p>起初，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>。这样就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537127.png" alt="git-br-initial"></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537128.png" alt="git-br-create"></p><blockquote><p>注意：每次从远程库克隆的分支均为master分支</p></blockquote><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537129.png" alt="git-br-dev-fd"></p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537130.png" alt="git-br-ff-merge"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537131.png" alt="git-br-rm"></p><h4 id="2-实例"><a href="#2-实例" class="headerlink" title="2 实例"></a>2 实例</h4><p>下面开始实战。</p><h5 id="（1）创建分支"><a href="#（1）创建分支" class="headerlink" title="（1）创建分支"></a>（1）创建分支</h5><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch dev   <span class="token comment">#建立分支</span>$ <span class="token function">git</span> checkout dev  <span class="token comment">#切换分支</span>Switched to branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="（2）查看分支状态"><a href="#（2）查看分支状态" class="headerlink" title="（2）查看分支状态"></a>（2）查看分支状态</h5><p>然后，用<code>git branch</code>命令查看当前分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Creating a new branch is quick.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"branch test"</span><span class="token punctuation">[</span>dev b17d20e<span class="token punctuation">]</span> branch <span class="token builtin class-name">test</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537132.png" alt="git-br-on-master"></p><h5 id="合并分支-1"><a href="#合并分支-1" class="headerlink" title="合并分支"></a>合并分支</h5><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge devUpdating d46f35e<span class="token punctuation">..</span>b17d20eFast-forward readme.txt <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==<code>git merge</code>命令用于合并指定分支到当前分支。==</p><p>合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><h5 id="删除分支-1"><a href="#删除分支-1" class="headerlink" title="删除分支"></a>删除分支</h5><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> devDeleted branch dev <span class="token punctuation">(</span>was b17d20e<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h4 id="3-分支切换"><a href="#3-分支切换" class="headerlink" title="3 分支切换"></a>3 分支切换</h4><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接切换到已有的<code>master</code>分支，可以使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p><h4 id="4-重要知识点小结"><a href="#4-重要知识点小结" class="headerlink" title="4 重要知识点小结"></a>4 重要知识点小结</h4><p>Git鼓励大量使用分支：</p><p>从远程库克隆指定分支到本地（以test为例）：<code>git checkout -b test origin/test</code></p><p>作用是checkout远程的test分支，在本地起名为test分支，并切换到本地的test分支</p><p>查看本地分支：<code>git branch</code></p><p>查看所有分支（本地和远程）：<code>git branch -a</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code><strong>推荐使用switch方法。</strong></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code>。<strong>推荐使用switch方法。</strong></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code>    强制删除<code>git branch -D &lt;name&gt;</code></p><h2 id="六-解决分支冲突"><a href="#六-解决分支冲突" class="headerlink" title="六 解决分支冲突"></a>六 解决分支冲突</h2><h4 id="分支冲突情况"><a href="#分支冲突情况" class="headerlink" title="分支冲突情况"></a>分支冲突情况</h4><p>当两个分支对相同的文件做处理时，产生分支冲突。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> feature1Switched to a new branch <span class="token string">'feature1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改<code>readme.txt</code>最后一行，改为：</p><pre class="line-numbers language-none"><code class="language-none">Creating a new branch is quick AND simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>feature1</code>分支上提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"AND simple"</span><span class="token punctuation">[</span>feature1 14096d0<span class="token punctuation">]</span> AND simple <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到<code>master</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">1</span> commit.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><pre class="line-numbers language-none"><code class="language-none">Creating a new branch is quick &amp; simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"&amp; simple"</span><span class="token punctuation">[</span>master 5dc6824<span class="token punctuation">]</span> <span class="token operator">&amp;</span> simple <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537133.png" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge feature1Auto-merging readme.txtCONFLICT <span class="token punctuation">(</span>content<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> readme.txtAutomatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">2</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>You have unmerged paths.  <span class="token punctuation">(</span>fix conflicts and run <span class="token string">"git commit"</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git merge --abort"</span> to abort the merge<span class="token punctuation">)</span>Unmerged paths:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to mark resolution<span class="token punctuation">)</span>both modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以直接查看readme.txt的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;</span> HEADCreating a new branch is quick <span class="token operator">&amp;</span> simple.<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Creating a new branch is quick AND simple.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> feature1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><pre class="line-numbers language-none"><code class="language-none">Creating a new branch is quick and simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容。</p><p>master前进一步</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"conflict fixed"</span><span class="token punctuation">[</span>master cf810e4<span class="token punctuation">]</span> conflict fixed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537134.png" alt="git-br-conflict-merged"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit*   cf810e4 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> conflict fixed<span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> * 14096d0 <span class="token punctuation">(</span>feature1<span class="token punctuation">)</span> AND simple* <span class="token operator">|</span> 5dc6824 <span class="token operator">&amp;</span> simple<span class="token operator">|</span>/  * b17d20e branch <span class="token builtin class-name">test</span>* d46f35e <span class="token punctuation">(</span>origin/master<span class="token punctuation">)</span> remove test.txt* b84166e <span class="token function">add</span> test.txt* 519219b <span class="token function">git</span> tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc <span class="token function">add</span> distributed* eaadf4e wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>冲突解决即合并完成，此时删除<code>feature1</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> feature1Deleted branch feature1 <span class="token punctuation">(</span>was 14096d0<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>工作完成。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><h4 id="保留分支信息"><a href="#保留分支信息" class="headerlink" title="保留分支信息"></a>保留分支信息</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，仍然创建并切换<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改readme.txt文件，并提交一个新的commit：</p><pre class="line-numbers language-none"><code class="language-none">$ git add readme.txt $ git commit -m "add merge"[dev f52c633] add merge 1 file changed, 1 insertion(+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们切换回<code>master</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge --no-ff <span class="token parameter variable">-m</span> <span class="token string">"merge with no-ff"</span> devMerge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit*   e1e9c68 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> merge with no-ff<span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> * f52c633 <span class="token punctuation">(</span>dev<span class="token punctuation">)</span> <span class="token function">add</span> merge<span class="token operator">|</span>/  *   cf810e4 conflict fixed<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537135.png" alt="git-no-ff-mode"></p><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，仍然创建并切换<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改readme.txt文件，并提交一个新的commit：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add merge"</span><span class="token punctuation">[</span>dev f52c633<span class="token punctuation">]</span> <span class="token function">add</span> merge <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们切换回<code>master</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge --no-ff <span class="token parameter variable">-m</span> <span class="token string">"merge with no-ff"</span> devMerge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><pre class="line-numbers language-none"><code class="language-none">$ git log --graph --pretty=oneline --abbrev-commit*   e1e9c68 (HEAD -&gt; master) merge with no-ff|\  | * f52c633 (dev) add merge|/  *   cf810e4 conflict fixed...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode"></p><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537136.png" alt="git-br-policy"></p><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch devChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   hello.pyChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stashSaved working directory and index state WIP on dev: f52c633 <span class="token function">add</span> merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">6</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> issue-101Switched to a new branch <span class="token string">'issue-101'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"fix bug 101"</span><span class="token punctuation">[</span>issue-101 4c805e2<span class="token punctuation">]</span> fix bug <span class="token number">101</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">6</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>$ <span class="token function">git</span> merge --no-ff <span class="token parameter variable">-m</span> <span class="token string">"merged bug fix 101"</span> issue-101Merge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> <span class="token number">2</span> +- <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch devSwitched to branch <span class="token string">'dev'</span>$ <span class="token function">git</span> statusOn branch devnothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><pre class="line-numbers language-none"><code class="language-none">$ git stash liststash@{0}: WIP on dev: f52c633 add merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stash popOn branch devChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   hello.pyChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtDropped refs/stash@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">(</span>5d677e2ee266f39ea296182fb2354265b91b3b2a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stash list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p><p>有木有更简单的方法？</p><p>有！</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。</p><blockquote><p> 注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来，因为merge后会将现有修改覆盖而我们只需要修改的一部分</p></blockquote><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master$ <span class="token function">git</span> cherry-pick 4c805e2<span class="token punctuation">[</span>master 1d4b803<span class="token punctuation">]</span> fix bug <span class="token number">101</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？</p><p>当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> feature-vulcanSwitched to a new branch <span class="token string">'feature-vulcan'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>5分钟后，开发完毕：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> vulcan.py$ <span class="token function">git</span> statusOn branch feature-vulcanChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   vulcan.py$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add feature vulcan"</span><span class="token punctuation">[</span>feature-vulcan 287773e<span class="token punctuation">]</span> <span class="token function">add</span> feature vulcan <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> vulcan.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切回<code>dev</code>，准备合并：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！</p><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> feature-vulcanerror: The branch <span class="token string">'feature-vulcan'</span> is not fully merged.If you are sure you want to delete it, run <span class="token string">'git branch -D feature-vulcan'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-D</span> feature-vulcanDeleted branch feature-vulcan <span class="token punctuation">(</span>was 287773e<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>终于删除成功！</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>origin  git@github.com:michaelliao/learngit.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>origin  git@github.com:michaelliao/learngit.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:michaelliao/learngit.gitCloning into <span class="token string">'learngit'</span><span class="token punctuation">..</span>.remote: Counting objects: <span class="token number">40</span>, done.remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">21</span>/21<span class="token punctuation">)</span>, done.remote: Total <span class="token number">40</span> <span class="token punctuation">(</span>delta <span class="token number">14</span><span class="token punctuation">)</span>, reused <span class="token number">40</span> <span class="token punctuation">(</span>delta <span class="token number">14</span><span class="token punctuation">)</span>, pack-reused <span class="token number">0</span>Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">40</span>/40<span class="token punctuation">)</span>, done.Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">14</span>/14<span class="token punctuation">)</span>, done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> dev origin/dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> env.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add env"</span><span class="token punctuation">[</span>dev 7a5e5dd<span class="token punctuation">]</span> <span class="token function">add</span> <span class="token function">env</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> env.txt$ <span class="token function">git</span> push origin devCounting objects: <span class="token number">3</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">2</span>/2<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">3</span>/3<span class="token punctuation">)</span>, <span class="token number">308</span> bytes <span class="token operator">|</span> <span class="token number">308.00</span> KiB/s, done.Total <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git   f52c633<span class="token punctuation">..</span>7a5e5dd  dev -<span class="token operator">&gt;</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> env.txt<span class="token function">env</span>$ <span class="token function">git</span> <span class="token function">add</span> env.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add new env"</span><span class="token punctuation">[</span>dev 7bd91f1<span class="token punctuation">]</span> <span class="token function">add</span> new <span class="token function">env</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> env.txt$ <span class="token function">git</span> push origin devTo github.com:michaelliao/learngit.git <span class="token operator">!</span> <span class="token punctuation">[</span>rejected<span class="token punctuation">]</span>        dev -<span class="token operator">&gt;</span> dev <span class="token punctuation">(</span>non-fast-forward<span class="token punctuation">)</span>error: failed to push some refs to <span class="token string">'git@github.com:michaelliao/learngit.git'</span>hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes <span class="token punctuation">(</span>e.g.hint: <span class="token string">'git pull ...'</span><span class="token punctuation">)</span> before pushing again.hint: See the <span class="token string">'Note about fast-forwards'</span> <span class="token keyword">in</span> <span class="token string">'git push --help'</span> <span class="token keyword">for</span> details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> pullThere is no tracking information <span class="token keyword">for</span> the current branch.Please specify <span class="token function">which</span> branch you want to merge with.See git-pull<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> details.    <span class="token function">git</span> pull <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>If you wish to <span class="token builtin class-name">set</span> tracking information <span class="token keyword">for</span> this branch you can <span class="token keyword">do</span> so with:    <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/<span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/dev devBranch <span class="token string">'dev'</span> <span class="token builtin class-name">set</span> up to track remote branch <span class="token string">'dev'</span> from <span class="token string">'origin'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再pull：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> pullAuto-merging env.txtCONFLICT <span class="token punctuation">(</span>add/add<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> env.txtAutomatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"fix env conflict"</span><span class="token punctuation">[</span>dev 57c53ab<span class="token punctuation">]</span> fix <span class="token function">env</span> conflict$ <span class="token function">git</span> push origin devCounting objects: <span class="token number">6</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">4</span>/4<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">6</span>/6<span class="token punctuation">)</span>, <span class="token number">621</span> bytes <span class="token operator">|</span> <span class="token number">621.00</span> KiB/s, done.Total <span class="token number">6</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git   7a5e5dd<span class="token punctuation">..</span>57c53ab  dev -<span class="token operator">&gt;</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><p>每次合并再push后，分支变成了这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit* d1be385 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master, origin/master<span class="token punctuation">)</span> init hello*   e5e69f1 Merge branch <span class="token string">'dev'</span><span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> *   57c53ab <span class="token punctuation">(</span>origin/dev, dev<span class="token punctuation">)</span> fix <span class="token function">env</span> conflict<span class="token operator">|</span> <span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> <span class="token operator">|</span> * 7a5e5dd <span class="token function">add</span> <span class="token function">env</span><span class="token operator">|</span> * <span class="token operator">|</span> 7bd91f1 <span class="token function">add</span> new <span class="token function">env</span><span class="token operator">|</span> <span class="token operator">|</span>/  * <span class="token operator">|</span>   12a631b merged bug fix <span class="token number">101</span><span class="token operator">|</span><span class="token punctuation">\</span> <span class="token punctuation">\</span>  <span class="token operator">|</span> * <span class="token operator">|</span> 4c805e2 fix bug <span class="token number">101</span><span class="token operator">|</span>/ /  * <span class="token operator">|</span>   e1e9c68 merge with no-ff<span class="token operator">|</span><span class="token punctuation">\</span> <span class="token punctuation">\</span>  <span class="token operator">|</span> <span class="token operator">|</span>/  <span class="token operator">|</span> * f52c633 <span class="token function">add</span> merge<span class="token operator">|</span>/  *   cf810e4 conflict fixed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p><p>其实是可以做到的！</p><p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537137.jpeg" alt="rebase"></p><p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><pre class="line-numbers language-none"><code class="language-none">$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello*   e5e69f1 Merge branch 'dev'|\  | *   57c53ab (origin/dev, dev) fix env conflict| |\  | | * 7a5e5dd add env| * | 7bd91f1 add new env...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin masterTo github.com:michaelliao/learngit.git <span class="token operator">!</span> <span class="token punctuation">[</span>rejected<span class="token punctuation">]</span>        master -<span class="token operator">&gt;</span> master <span class="token punctuation">(</span>fetch first<span class="token punctuation">)</span>error: failed to push some refs to <span class="token string">'git@github.com:michaelliao/learngit.git'</span>hint: Updates were rejected because the remote contains work that you <span class="token keyword">do</span>hint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: <span class="token punctuation">(</span>e.g., <span class="token string">'git pull ...'</span><span class="token punctuation">)</span> before pushing again.hint: See the <span class="token string">'Note about fast-forwards'</span> <span class="token keyword">in</span> <span class="token string">'git push --help'</span> <span class="token keyword">for</span> details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> pullremote: Counting objects: <span class="token number">3</span>, done.remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1</span>/1<span class="token punctuation">)</span>, done.remote: Total <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">1</span><span class="token punctuation">)</span>, reused <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">1</span><span class="token punctuation">)</span>, pack-reused <span class="token number">0</span>Unpacking objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">3</span>/3<span class="token punctuation">)</span>, done.From github.com:michaelliao/learngit   d1be385<span class="token punctuation">..</span>f005ed4  master     -<span class="token operator">&gt;</span> origin/master * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.0       -<span class="token operator">&gt;</span> v1.0Auto-merging hello.pyMerge made by the <span class="token string">'recursive'</span> strategy. hello.py <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用<code>git status</code>看看状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">3</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>nothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><p>用<code>git log</code>看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit*   e0ea545 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> Merge branch <span class="token string">'master'</span> of github.com:michaelliao/learngit<span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> * f005ed4 <span class="token punctuation">(</span>origin/master<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> <span class="token assign-left variable">exit</span><span class="token operator">=</span><span class="token number">1</span>* <span class="token operator">|</span> 582d922 <span class="token function">add</span> author* <span class="token operator">|</span> <span class="token number">8875536</span> <span class="token function">add</span> comment<span class="token operator">|</span>/  * d1be385 init hello<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p><p>有！</p><p>什么问题？</p><p>不好看！</p><p>有没有解决方法？</p><p>有！</p><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> rebaseFirst, rewinding <span class="token function">head</span> to replay your work on <span class="token function">top</span> of it<span class="token punctuation">..</span>.Applying: <span class="token function">add</span> commentUsing index info to reconstruct a base tree<span class="token punctuation">..</span>.Mhello.pyFalling back to patching base and <span class="token number">3</span>-way merge<span class="token punctuation">..</span>.Auto-merging hello.pyApplying: <span class="token function">add</span> authorUsing index info to reconstruct a base tree<span class="token punctuation">..</span>.Mhello.pyFalling back to patching base and <span class="token number">3</span>-way merge<span class="token punctuation">..</span>.Auto-merging hello.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit* 7e61ed4 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> <span class="token function">add</span> author* 3611cfe <span class="token function">add</span> comment* f005ed4 <span class="token punctuation">(</span>origin/master<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> <span class="token assign-left variable">exit</span><span class="token operator">=</span><span class="token number">1</span>* d1be385 init hello<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Mac:~/learngit michael$ <span class="token function">git</span> push origin masterCounting objects: <span class="token number">6</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">5</span>/5<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">6</span>/6<span class="token punctuation">)</span>, <span class="token number">576</span> bytes <span class="token operator">|</span> <span class="token number">576.00</span> KiB/s, done.Total <span class="token number">6</span> <span class="token punctuation">(</span>delta <span class="token number">2</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>remote: Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">2</span>/2<span class="token punctuation">)</span>, completed with <span class="token number">1</span> <span class="token builtin class-name">local</span> object.To github.com:michaelliao/learngit.git   f005ed4<span class="token punctuation">..</span>7e61ed4  master -<span class="token operator">&gt;</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用<code>git log</code>看看效果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit* 7e61ed4 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master, origin/master<span class="token punctuation">)</span> <span class="token function">add</span> author* 3611cfe <span class="token function">add</span> comment* f005ed4 <span class="token builtin class-name">set</span> <span class="token assign-left variable">exit</span><span class="token operator">=</span><span class="token number">1</span>* d1be385 init hello<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>远程分支的提交历史也是一条直线。</p><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以用命令<code>git tag</code>查看所有标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit12a631b <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master, tag: v1.0, origin/master<span class="token punctuation">)</span> merged bug fix <span class="token number">101</span>4c805e2 fix bug <span class="token number">101</span>e1e9c68 merge with no-fff52c633 <span class="token function">add</span> mergecf810e4 conflict fixed5dc6824 <span class="token operator">&amp;</span> simple14096d0 AND simpleb17d20e branch <span class="token builtin class-name">test</span>d46f35e remove test.txtb84166e <span class="token function">add</span> test.txt519219b <span class="token function">git</span> tracks changese43a48b understand how stage works1094adb append GPLe475afc <span class="token function">add</span> distributedeaadf4e wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag v0.9 f52c633<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用命令<code>git tag</code>查看标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv0.9v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 <span class="token punctuation">(</span>tag: v0.9<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:56:54 <span class="token number">2018</span> +0800    <span class="token function">add</span> merge<span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txt<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-a</span> v0.1 <span class="token parameter variable">-m</span> <span class="token string">"version 0.1 released"</span> 1094adb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v0.1tag v0.1Tagger: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">22</span>:48:43 <span class="token number">2018</span> +0800version <span class="token number">0.1</span> releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="token punctuation">(</span>tag: v0.1<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:06:15 <span class="token number">2018</span> +0800    append GPL<span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txt<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-d</span> v0.1Deleted tag <span class="token string">'v0.1'</span> <span class="token punctuation">(</span>was f15b0dd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin v1.0Total <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.0 -<span class="token operator">&gt;</span> v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin <span class="token parameter variable">--tags</span>Total <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v0.9 -<span class="token operator">&gt;</span> v0.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-d</span> v0.9Deleted tag <span class="token string">'v0.9'</span> <span class="token punctuation">(</span>was f52c633<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - <span class="token punctuation">[</span>deleted<span class="token punctuation">]</span>         v0.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h2 id="七-使用GitHub"><a href="#七-使用GitHub" class="headerlink" title="七 使用GitHub"></a>七 使用GitHub</h2><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p><p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap%EF%BC%8C%E7%82%B9%E2%80%9CFork%E2%80%9D%E5%B0%B1%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8B%E5%85%8B%E9%9A%86%E4%BA%86%E4%B8%80%E4%B8%AAbootstrap%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%EF%BC%8C%E4%BB%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8Bclone%EF%BC%9A">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p><pre class="line-numbers language-none"><code class="language-none">git clone git@github.com:michaelliao/bootstrap.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">┌─ GitHub ────────────────────────────────────┐│                                             ││ ┌─────────────────┐     ┌─────────────────┐ ││ │ twbs/bootstrap  │────&gt;│  my/bootstrap   │ ││ └─────────────────┘     └─────────────────┘ ││                                  ▲          │└──────────────────────────────────┼──────────┘                                   ▼                          ┌─────────────────┐                          │ local/bootstrap │                          └─────────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%60your-github-id.txt%60%E7%9A%84%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%99%E7%82%B9%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0Git%E7%9A%84%E5%BF%83%E5%BE%97%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8E%A8%E9%80%81%E4%B8%80%E4%B8%AApull">https://github.com/michaelliao/learngit，创建一个`your-github-id.txt`的文本文件，写点自己学习Git的心得，然后推送一个pull</a> request给我，我会视心情而定是否接受。</p><hr><h2 id="八-总结"><a href="#八-总结" class="headerlink" title="八 总结"></a>八 总结</h2><p>步骤:</p><ol><li><p>创建本地仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>远程仓库</p><ol><li>关联版本库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin  git@gitee.com:gyjiang/NS3LoadBalance.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>将本地仓库添加至暂存区</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>推送</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">   <span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master<span class="token operator">!</span><span class="token punctuation">[</span>git<span class="token punctuation">]</span><span class="token punctuation">(</span>https://gitee.com/jgyong/blogimg/raw/master/img/202302191537138.png<span class="token punctuation">)</span><span class="token comment">## 九 出现的问题以及解决方法</span><span class="token comment">### 1 “ssh:connect to host github.com port 22: Connection timed out”</span>方法思路：更换端口（参考<span class="token punctuation">[</span>^1<span class="token punctuation">]</span>）<span class="token number">1</span>.   进入~/.ssh<span class="token number">2</span>.   修改config文件<span class="token number">3</span>.   编辑文件内容     ```git     Host github.com     User <span class="token function">git</span>     Hostname ssh.github.com     PreferredAuthentications publickey     IdentityFile ~/.ssh/id_rsa     Port <span class="token number">443</span>          Host gitlab.com     Hostname altssh.gitlab.com     User <span class="token function">git</span>     Port <span class="token number">443</span>     PreferredAuthentications publickey     IdentityFile ~/.ssh/id_rsa     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>保存退出</p></li><li><p>检查是否成功</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[^1]:<a href="https://blog.csdn.net/weixin_45637036/article/details/106560217">Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用手册</title>
      <link href="/2023/07/21/git/git-shi-yong-shou-ce/"/>
      <url>/2023/07/21/git/git-shi-yong-shou-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><p>Linux</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WIndows</p><p>“Git”-&gt;“Git Bash”</p><h3 id="1-1-配置"><a href="#1-1-配置" class="headerlink" title="1.1 配置"></a>1.1 配置</h3><p>分布式版本控制，所有机器自报家门</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"Your Name"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="1-2-私有数据库下载权限设置"><a href="#1-2-私有数据库下载权限设置" class="headerlink" title="1.2 私有数据库下载权限设置"></a>1.2 私有数据库下载权限设置</h3><p>如果需要下载私有仓库内容，需要将SSH添加至远程库中，获取相应权限后，方可克隆文件。</p><p>你可以按如下命令来生成 sshkey:</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t ed25519 -C "xxxxx@xxxxx.com"  # Generating public/private ed25519 key pair...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意：这里的 <code>xxxxx@xxxxx.com</code> 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱。<br>现网的大部分教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱。</p></blockquote><p>按照提示完成三次回车，即可生成 ssh key。通过查看 <code>~/.ssh/id_ed25519.pub</code> 文件内容，获取到你的 public key</p><blockquote><p>注意:</p><p>不同的電腦公钥的位置可能不同。公钥所在的位置根据在生成公钥的命令行提示内容处获取【见下图】</p></blockquote><pre class="line-numbers language-none"><code class="language-none">cat ~/.ssh/id_ed25519.pub# ssh-ed25519 AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537110.png" alt="SSH生成"></p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537112.png" alt="image-20220630163316806"></p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537113.png" alt="输入图片说明"></p><p>复制生成后的 ssh key，通过仓库主页 <strong>「管理」-&gt;「部署公钥管理」-&gt;「添加部署公钥」</strong> ，添加生成的 public key 添加到仓库中。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537114.png" alt="添加部署公钥"></p><p>添加后，在终端（Terminal）中输入</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@gitee.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首次使用需要确认并添加主机到本机SSH可信列表。若返回 <code>Hi XXX! You've successfully authenticated, but Gitee.com does not provide shell access.</code> 内容，则证明添加成功。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537115.png" alt="SSH添加提示"></p><p>添加成功后，就可以使用SSH协议对仓库进行操作了。</p><h3 id="1-3-仓库公钥和可部署公钥"><a href="#1-3-仓库公钥和可部署公钥" class="headerlink" title="1.3 仓库公钥和可部署公钥"></a>1.3 仓库公钥和可部署公钥</h3><p>为了便于用户在多个项目仓库下使用一套公钥，免于重复部署和管理的繁琐，Gitee 推出了「可部署公钥」功能，支持在一个仓库空间下使用当前账户名下/参与的另一个仓库空间的部署公钥，实现公钥共用。</p><h3 id="1-4-个人公钥"><a href="#1-4-个人公钥" class="headerlink" title="1.4 个人公钥"></a>1.4 个人公钥</h3><p>添加个人公钥后，对于所有的仓库都有读写权限。</p><h2 id="二-版本库"><a href="#二-版本库" class="headerlink" title="二 版本库"></a>二 版本库</h2><p>版本库又名仓库，英文名<strong>repository</strong>。可以简单理解成一个目录。</p><p>Git仓库表示该目录下所有文件都被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><ol><li>创建空目录</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> learngit<span class="token builtin class-name">cd</span> learngit<span class="token builtin class-name">pwd</span>/Users/michael/learngit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文</p></blockquote><ol start="2"><li>将目录变为Git可管理的仓库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> initInitialized empty Git repository <span class="token keyword">in</span> /Users/michael/learngit/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完成创建。</p><p>其中，初始化后目录下增加<code>.git</code>目录。该目录用于跟踪管理版本库的。千万不能修改</p><ol start="3"><li><p>文件添加至版本库</p><blockquote><p>所有版本控制系统，只能跟踪文件的改动，比如TXT、网页、程序代码</p><p>图片、视频二进制文件无法追踪文件变化。其中Word也是二进制格式。</p></blockquote><p>其中，文件添加至版本库分两步：添加与提交</p><ol><li>用命令<code>git add</code>告诉Git，把文件添加到仓库：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>用命令<code>git commit</code>告诉Git，把文件提交到仓库：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"wrote a readme file"</span><span class="token punctuation">[</span>master <span class="token punctuation">(</span>root-commit<span class="token punctuation">)</span> eaadf4e<span class="token punctuation">]</span> wrote a readme <span class="token function">file</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，用于从历史记录里方便地找到改动记录。</p><p>也可以不输入<code>-m "xxx"</code>，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p><strong>分为两步的原因</strong></p><p>add添加可以每次添加不同的文件，根据自己改的文件进行添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> file1.txt$ <span class="token function">git</span> <span class="token function">add</span> file2.txt file3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>commit一次提交所有更改文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add 3 files."</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="三-版本回退"><a href="#三-版本回退" class="headerlink" title="三 版本回退"></a>三 版本回退</h2><h3 id="3-1-相关操作"><a href="#3-1-相关操作" class="headerlink" title="3.1 相关操作"></a>3.1 相关操作</h3><ol><li><p>随时查看仓库状态</p><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态</p><p>若修改readme.txt文件，改成如下内容：</p><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，运行<code>git status</code>命令看看结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p></li><li><p>查看修改内容</p><p>如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> readme.txt <span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txtindex 46d49bf<span class="token punctuation">..</span>9247db6 <span class="token number">100644</span>--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@<span class="token parameter variable">-Git</span> is a version control system.+Git is a distributed version control system. Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>提交修改</p><p>同样为添加与提交两步</p><p>第一步是<code>git add</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code>显示：将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add distributed"</span><span class="token punctuation">[</span>master e475afc<span class="token punctuation">]</span> <span class="token function">add</span> distributed <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p></li></ol><h3 id="3-2-版本快照"><a href="#3-2-版本快照" class="headerlink" title="3.2 版本快照"></a>3.2 版本快照</h3><p>类似游戏的手动存盘。每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。</p><p>快照的作用为：一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>版本1：wrote a readme file</p><pre class="line-numbers language-none"><code class="language-none">Git is a version control system.Git is free software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本2：add distributed</p><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本3：append GPL</p><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="查看之间快照"><a href="#查看之间快照" class="headerlink" title="查看之间快照"></a>查看之间快照</h5><p>在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，</p><p>在Git中，我们可用<code>git log</code>命令查看修改历史记录，</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:06:15 <span class="token number">2018</span> +0800    append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:03:36 <span class="token number">2018</span> +0800    <span class="token function">add</span> distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">20</span>:59:18 <span class="token number">2018</span> +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> append GPLe475afc93c209a690c39c13a46716e8fa000c366 <span class="token function">add</span> distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>前面一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）。</p><p>Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><p>为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。</p><h5 id="回退快照"><a href="#回退快照" class="headerlink" title="回退快照"></a>回退快照</h5><p>  我们准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><ol><li>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</li><li>把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD^HEAD is now at e475afc <span class="token function">add</span> distributed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>果然被还原了。</p><p>让我们用<code>git log</code>再看看现在版本库的状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> logcommit e475afc93c209a690c39c13a46716e8fa000c366 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:03:36 <span class="token number">2018</span> +0800    <span class="token function">add</span> distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">20</span>:59:18 <span class="token number">2018</span> +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>在未关闭命令行界面的情况下，回到最新的版本</li></ol><p>查看log发现最新的那个版本<code>append GPL</code>已经看不到了！但如何回到最新状态？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> 1094aHEAD is now at 83b0afe append GPL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><pre class="line-numbers language-none"><code class="language-none">$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   └──&gt; ○ append GPL        │        ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改为指向<code>add distributed</code>：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   │    ○ append GPL   │    │   └──&gt; ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><ol start="4"><li><p>在关闭命令行界面的情况下，回到最新的版本：使用 <code>git reflog</code></p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，当用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。</p><p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> refloge475afc HEAD@<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>: reset: moving to HEAD^1094adb <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>: commit: append GPLe475afc HEAD@<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span>: commit: <span class="token function">add</span> distributedeaadf4e HEAD@<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span>: commit <span class="token punctuation">(</span>initial<span class="token punctuation">)</span>: wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>。</p><h3 id="3-3-Git修改文件原理"><a href="#3-3-Git修改文件原理" class="headerlink" title="3.3 Git修改文件原理"></a>3.3 Git修改文件原理</h3><h4 id="1-工作区（Working-Directory）"><a href="#1-工作区（Working-Directory）" class="headerlink" title="1. 工作区（Working Directory）"></a>1. 工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537116.png" alt="working-dir"></p><h4 id="2-版本库（Repository）"><a href="#2-版本库（Repository）" class="headerlink" title="2. 版本库（Repository）"></a>2. 版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西。</p><p>其中最重要的就是称为stage（或者叫index）的暂存区。</p><p>还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><h4 id="Git分区示意图"><a href="#Git分区示意图" class="headerlink" title="Git分区示意图"></a>Git分区示意图</h4><p>Git主要可以分为工作区、暂存区与分支。其中暂存区与分支存放在版本库中。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537117.jpeg" alt="git-repo"></p><h4 id="具体联系"><a href="#具体联系" class="headerlink" title="具体联系"></a>具体联系</h4><p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步<code>git add</code>：实际上就是把文件修改添加到暂存区；</p><p>第二步<code>git commit</code>：实际上就是把暂存区的所有内容提交到当前分支。</p><p>当我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支。所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>即两次过程为1.将需要提交的文件修改通通放到暂存区  2 .一次性提交暂存区的所有修改。</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><ol><li><p>工作区内容修改</p><p>先对<code>readme.txt</code>做个修改，比如加上一行内容：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtUntracked files:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>LICENSEno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><ol start="2"><li><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage）。</li></ol><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   LICENSEmodified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537118.jpeg" alt="git-stage"></p><ol start="3"><li>执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"understand how stage works"</span><span class="token punctuation">[</span>master e43a48b<span class="token punctuation">]</span> understand how stage works <span class="token number">2</span> files changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> LICENSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537119.jpeg" alt="git-stage-after-commit"></p><h4 id="Git管理原理"><a href="#Git管理原理" class="headerlink" title="Git管理原理"></a>Git管理原理</h4><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。其中，工作区存储文件，暂存区存储相应修改。即只修改工作区而不提交暂存区，Git将无法管理。</p><h5 id="什么是修改？"><a href="#什么是修改？" class="headerlink" title="什么是修改？"></a>什么是修改？</h5><p>比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改</p><h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><p>第一步，对readme.txt做一个修改，比如加一行内容：</p><pre class="line-numbers language-none"><code class="language-none">$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，添加：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt$ <span class="token function">git</span> status<span class="token comment"># On branch master</span><span class="token comment"># Changes to be committed:</span><span class="token comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span><span class="token comment">#</span><span class="token comment">#       modified:   readme.txt</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，再修改readme.txt：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txt Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时不将文件修改后内容放置暂存区，直接提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"git tracks changes"</span><span class="token punctuation">[</span>master 519219b<span class="token punctuation">]</span> <span class="token function">git</span> tracks changes <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，再看看状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们回顾一下操作过程：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code>。发现第二次的修改没有被提交？</p><p>原因为Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>最后，使用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> HEAD -- readme.txt <span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txtindex 76d770f<span class="token punctuation">..</span>a9c5755 <span class="token number">100644</span>--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is <span class="token function">free</span> software distributed under the GPL. Git has a mutable index called stage.<span class="token parameter variable">-Git</span> tracks changes.+Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那怎么提交第二次修改呢？</p><p>可以继续<code>git add</code>再<code>git commit</code>；</p><p>也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h5 id="情景1：丢弃工作区修改：git-checkout-–-file"><a href="#情景1：丢弃工作区修改：git-checkout-–-file" class="headerlink" title="情景1：丢弃工作区修改：git checkout – file"></a>情景1：丢弃工作区修改：git checkout – file</h5><p>想象场景，你在<code>readme.txt</code>中添加了一行：</p><pre class="line-numbers language-none"><code class="language-none">$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="丢弃修改"><a href="#丢弃修改" class="headerlink" title="丢弃修改"></a>丢弃修改</h6><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销。</p><p>这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><h5 id="情景2：丢弃暂存区修改：git-reset-HEAD-lt-file-gt"><a href="#情景2：丢弃暂存区修改：git-reset-HEAD-lt-file-gt" class="headerlink" title="情景2：丢弃暂存区修改：git reset HEAD <file>"></a>情景2：丢弃暂存区修改：git reset HEAD &lt;file&gt;</h5><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ <span class="token function">git</span> <span class="token function">add</span> readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> reset HEAD readme.txtUnstaged changes after reset:Mreadme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还记得如何丢弃工作区的修改吗？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- readme.txt$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个世界终于清静了！</p><h5 id="情景3：丢弃本地分支修改：git-reset-HEAD-readme-txt"><a href="#情景3：丢弃本地分支修改：git-reset-HEAD-readme-txt" class="headerlink" title="情景3：丢弃本地分支修改：git reset HEAD readme.txt"></a>情景3：丢弃本地分支修改：git reset HEAD readme.txt</h5><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？</p><p>还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><h4 id="正常删除"><a href="#正常删除" class="headerlink" title="正常删除"></a>正常删除</h4><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> test.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add test.txt"</span><span class="token punctuation">[</span>master b84166e<span class="token punctuation">]</span> <span class="token function">add</span> test.txt <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add/rm &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>deleted:    test.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> test.txt<span class="token function">rm</span> <span class="token string">'test.txt'</span>$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"remove test.txt"</span><span class="token punctuation">[</span>master d46f35e<span class="token punctuation">]</span> remove test.txt <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span> delete mode <span class="token number">100644</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，文件就从版本库中被删除了。</p><blockquote><p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</file></file></p></blockquote><h4 id="误删文件后恢复"><a href="#误删文件后恢复" class="headerlink" title="误删文件后恢复"></a>误删文件后恢复</h4><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout -- test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的</p><h2 id="四-远程仓库"><a href="#四-远程仓库" class="headerlink" title="四 远程仓库"></a>四 远程仓库</h2><h3 id="4-1-远程仓库"><a href="#4-1-远程仓库" class="headerlink" title="4.1 远程仓库"></a>4.1 远程仓库</h3><p>远程仓库的作用是一方面防止本地硬盘损坏而导致项目代码丢失，另一方面方便多人对于同一工程文件的修改与完善。</p><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。</p><p>不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。</p><h4 id="1-设置Git秘钥"><a href="#1-设置Git秘钥" class="headerlink" title="1 设置Git秘钥"></a>1 设置Git秘钥</h4><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><p>第1步：创建SSH Key。</p><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537120.png" alt="github-addkey-1"></p><p>点“Add Key”，你就应该看到已经添加的Key：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537121.png" alt="github-addkey-2"></p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p><p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的操作。</p><h3 id="4-2-添加远程库"><a href="#4-2-添加远程库" class="headerlink" title="4.2 添加远程库"></a>4.2 添加远程库</h3><p>  你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p><h5 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1 步骤"></a>1 步骤</h5><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919021631860000/0" alt="github-create-repo-1"></p><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537122.png" alt="github-create-repo-2"></p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:michaelliao/learngit.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，==远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。==</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push <span class="token parameter variable">-u</span> origin masterCounting objects: <span class="token number">20</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">15</span>/15<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">20</span>/20<span class="token punctuation">)</span>, <span class="token number">1.64</span> KiB <span class="token operator">|</span> <span class="token number">560.00</span> KiB/s, done.Total <span class="token number">20</span> <span class="token punctuation">(</span>delta <span class="token number">5</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>remote: Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">5</span>/5<span class="token punctuation">)</span>, done.To github.com:michaelliao/learngit.git * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      master -<span class="token operator">&gt;</span> masterBranch <span class="token string">'master'</span> <span class="token builtin class-name">set</span> up to track remote branch <span class="token string">'master'</span> from <span class="token string">'origin'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537123.png" alt="github-repo"></p><p>从现在起，只要本地作了提交，就可以通过命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h4 id="2-SSH警告"><a href="#2-SSH警告" class="headerlink" title="2 SSH警告"></a>2 SSH警告</h4><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><pre class="line-numbers language-none"><code class="language-none">The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre class="line-numbers language-none"><code class="language-none">Warning: Permanently added 'github.com' (RSA) to the list of known hosts.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h3 id="4-3-删除远程库"><a href="#4-3-删除远程库" class="headerlink" title="4.3 删除远程库"></a>4.3 删除远程库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>origin  git@github.com:michaelliao/learn-git.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>origin  git@github.com:michaelliao/learn-git.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，根据名字删除，比如删除<code>origin</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token function">rm</span> origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h3 id="4-4-克隆远程库"><a href="#4-4-克隆远程库" class="headerlink" title="4.4 克隆远程库"></a>4.4 克隆远程库</h3><p>以上内容为先有本地库，后有远程库的时候，如何关联远程库。</p><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537124.png" alt="github-init-repo"></p><p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537125.png" alt="github-init-repo-2"></p><p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:michaelliao/gitskills.gitCloning into <span class="token string">'gitskills'</span><span class="token punctuation">..</span>.remote: Counting objects: <span class="token number">3</span>, done.remote: Total <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, pack-reused <span class="token number">3</span>Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">3</span>/3<span class="token punctuation">)</span>, done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> gitskills$ <span class="token function">ls</span>README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code></p><h2 id="五-分支管理"><a href="#五-分支管理" class="headerlink" title="五 分支管理"></a>五 分支管理</h2><h3 id="5-1分支管理"><a href="#5-1分支管理" class="headerlink" title="5.1分支管理"></a>5.1分支管理</h3><h4 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a>1 应用场景</h4><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537126.png" alt="learn-branches"></p><p>开发新功能但未完成。</p><p>立刻提交不完整的代码库导致别人无法继续工作</p><p>不提交存在丢失进度风险</p><h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2 解决方式"></a>2 解决方式</h4><p>建立自己分支，别人看不到。自己在自己分支工作。直至开发完毕后提交至原有分支</p><p>无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件</p><h3 id="5-2-创建合并分支"><a href="#5-2-创建合并分支" class="headerlink" title="5.2 创建合并分支"></a>5.2 创建合并分支</h3><h4 id="1-分支原理"><a href="#1-分支原理" class="headerlink" title="1 分支原理"></a>1 分支原理</h4><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。</p><p>截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。</p><p><code>HEAD</code>指向<code>master</code>，而<code>master</code>才是指向提交的。即<code>HEAD</code>指向的为当前分支。</p><p>起初，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>。这样就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537127.png" alt="git-br-initial"></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537128.png" alt="git-br-create"></p><blockquote><p>注意：每次从远程库克隆的分支均为master分支</p></blockquote><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537129.png" alt="git-br-dev-fd"></p><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537130.png" alt="git-br-ff-merge"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537131.png" alt="git-br-rm"></p><h4 id="2-实例"><a href="#2-实例" class="headerlink" title="2 实例"></a>2 实例</h4><p>下面开始实战。</p><h5 id="（1）创建分支"><a href="#（1）创建分支" class="headerlink" title="（1）创建分支"></a>（1）创建分支</h5><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch dev   <span class="token comment">#建立分支</span>$ <span class="token function">git</span> checkout dev  <span class="token comment">#切换分支</span>Switched to branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="（2）查看分支状态"><a href="#（2）查看分支状态" class="headerlink" title="（2）查看分支状态"></a>（2）查看分支状态</h5><p>然后，用<code>git branch</code>命令查看当前分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Creating a new branch is quick.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"branch test"</span><span class="token punctuation">[</span>dev b17d20e<span class="token punctuation">]</span> branch <span class="token builtin class-name">test</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537132.png" alt="git-br-on-master"></p><h5 id="合并分支-1"><a href="#合并分支-1" class="headerlink" title="合并分支"></a>合并分支</h5><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge devUpdating d46f35e<span class="token punctuation">..</span>b17d20eFast-forward readme.txt <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==<code>git merge</code>命令用于合并指定分支到当前分支。==</p><p>合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><h5 id="删除分支-1"><a href="#删除分支-1" class="headerlink" title="删除分支"></a>删除分支</h5><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> devDeleted branch dev <span class="token punctuation">(</span>was b17d20e<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h4 id="3-分支切换"><a href="#3-分支切换" class="headerlink" title="3 分支切换"></a>3 分支切换</h4><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接切换到已有的<code>master</code>分支，可以使用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p><h4 id="4-重要知识点小结"><a href="#4-重要知识点小结" class="headerlink" title="4 重要知识点小结"></a>4 重要知识点小结</h4><p>Git鼓励大量使用分支：</p><p>从远程库克隆指定分支到本地（以test为例）：<code>git checkout -b test origin/test</code></p><p>作用是checkout远程的test分支，在本地起名为test分支，并切换到本地的test分支</p><p>查看本地分支：<code>git branch</code></p><p>查看所有分支（本地和远程）：<code>git branch -a</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code><strong>推荐使用switch方法。</strong></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code>。<strong>推荐使用switch方法。</strong></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code>    强制删除<code>git branch -D &lt;name&gt;</code></p><h2 id="六-解决分支冲突"><a href="#六-解决分支冲突" class="headerlink" title="六 解决分支冲突"></a>六 解决分支冲突</h2><h4 id="分支冲突情况"><a href="#分支冲突情况" class="headerlink" title="分支冲突情况"></a>分支冲突情况</h4><p>当两个分支对相同的文件做处理时，产生分支冲突。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> feature1Switched to a new branch <span class="token string">'feature1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改<code>readme.txt</code>最后一行，改为：</p><pre class="line-numbers language-none"><code class="language-none">Creating a new branch is quick AND simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>feature1</code>分支上提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"AND simple"</span><span class="token punctuation">[</span>feature1 14096d0<span class="token punctuation">]</span> AND simple <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到<code>master</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">1</span> commit.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><pre class="line-numbers language-none"><code class="language-none">Creating a new branch is quick &amp; simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"&amp; simple"</span><span class="token punctuation">[</span>master 5dc6824<span class="token punctuation">]</span> <span class="token operator">&amp;</span> simple <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537133.png" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge feature1Auto-merging readme.txtCONFLICT <span class="token punctuation">(</span>content<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> readme.txtAutomatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">2</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>You have unmerged paths.  <span class="token punctuation">(</span>fix conflicts and run <span class="token string">"git commit"</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git merge --abort"</span> to abort the merge<span class="token punctuation">)</span>Unmerged paths:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to mark resolution<span class="token punctuation">)</span>both modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以直接查看readme.txt的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;</span> HEADCreating a new branch is quick <span class="token operator">&amp;</span> simple.<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Creating a new branch is quick AND simple.<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> feature1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><pre class="line-numbers language-none"><code class="language-none">Creating a new branch is quick and simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容。</p><p>master前进一步</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"conflict fixed"</span><span class="token punctuation">[</span>master cf810e4<span class="token punctuation">]</span> conflict fixed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537134.png" alt="git-br-conflict-merged"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit*   cf810e4 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> conflict fixed<span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> * 14096d0 <span class="token punctuation">(</span>feature1<span class="token punctuation">)</span> AND simple* <span class="token operator">|</span> 5dc6824 <span class="token operator">&amp;</span> simple<span class="token operator">|</span>/  * b17d20e branch <span class="token builtin class-name">test</span>* d46f35e <span class="token punctuation">(</span>origin/master<span class="token punctuation">)</span> remove test.txt* b84166e <span class="token function">add</span> test.txt* 519219b <span class="token function">git</span> tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc <span class="token function">add</span> distributed* eaadf4e wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>冲突解决即合并完成，此时删除<code>feature1</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> feature1Deleted branch feature1 <span class="token punctuation">(</span>was 14096d0<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>工作完成。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><h4 id="保留分支信息"><a href="#保留分支信息" class="headerlink" title="保留分支信息"></a>保留分支信息</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，仍然创建并切换<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改readme.txt文件，并提交一个新的commit：</p><pre class="line-numbers language-none"><code class="language-none">$ git add readme.txt $ git commit -m "add merge"[dev f52c633] add merge 1 file changed, 1 insertion(+)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们切换回<code>master</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge --no-ff <span class="token parameter variable">-m</span> <span class="token string">"merge with no-ff"</span> devMerge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit*   e1e9c68 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> merge with no-ff<span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> * f52c633 <span class="token punctuation">(</span>dev<span class="token punctuation">)</span> <span class="token function">add</span> merge<span class="token operator">|</span>/  *   cf810e4 conflict fixed<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537135.png" alt="git-no-ff-mode"></p><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，仍然创建并切换<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改readme.txt文件，并提交一个新的commit：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add merge"</span><span class="token punctuation">[</span>dev f52c633<span class="token punctuation">]</span> <span class="token function">add</span> merge <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们切换回<code>master</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> merge --no-ff <span class="token parameter variable">-m</span> <span class="token string">"merge with no-ff"</span> devMerge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><pre class="line-numbers language-none"><code class="language-none">$ git log --graph --pretty=oneline --abbrev-commit*   e1e9c68 (HEAD -&gt; master) merge with no-ff|\  | * f52c633 (dev) add merge|/  *   cf810e4 conflict fixed...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode"></p><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537136.png" alt="git-br-policy"></p><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch devChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   hello.pyChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stashSaved working directory and index state WIP on dev: f52c633 <span class="token function">add</span> merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">6</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> issue-101Switched to a new branch <span class="token string">'issue-101'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> readme.txt $ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"fix bug 101"</span><span class="token punctuation">[</span>issue-101 4c805e2<span class="token punctuation">]</span> fix bug <span class="token number">101</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">6</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>$ <span class="token function">git</span> merge --no-ff <span class="token parameter variable">-m</span> <span class="token string">"merged bug fix 101"</span> issue-101Merge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> <span class="token number">2</span> +- <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch devSwitched to branch <span class="token string">'dev'</span>$ <span class="token function">git</span> statusOn branch devnothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><pre class="line-numbers language-none"><code class="language-none">$ git stash liststash@{0}: WIP on dev: f52c633 add merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stash popOn branch devChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   hello.pyChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file&gt;..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>modified:   readme.txtDropped refs/stash@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token punctuation">(</span>5d677e2ee266f39ea296182fb2354265b91b3b2a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stash list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p><p>有木有更简单的方法？</p><p>有！</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。</p><blockquote><p> 注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来，因为merge后会将现有修改覆盖而我们只需要修改的一部分</p></blockquote><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master$ <span class="token function">git</span> cherry-pick 4c805e2<span class="token punctuation">[</span>master 1d4b803<span class="token punctuation">]</span> fix bug <span class="token number">101</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, <span class="token number">1</span> deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？</p><p>当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> feature-vulcanSwitched to a new branch <span class="token string">'feature-vulcan'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>5分钟后，开发完毕：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> vulcan.py$ <span class="token function">git</span> statusOn branch feature-vulcanChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file&gt;..."</span> to unstage<span class="token punctuation">)</span>new file:   vulcan.py$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add feature vulcan"</span><span class="token punctuation">[</span>feature-vulcan 287773e<span class="token punctuation">]</span> <span class="token function">add</span> feature vulcan <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">2</span> insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> vulcan.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切回<code>dev</code>，准备合并：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> switch dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！</p><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> feature-vulcanerror: The branch <span class="token string">'feature-vulcan'</span> is not fully merged.If you are sure you want to delete it, run <span class="token string">'git branch -D feature-vulcan'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch <span class="token parameter variable">-D</span> feature-vulcanDeleted branch feature-vulcan <span class="token punctuation">(</span>was 287773e<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>终于删除成功！</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>origin  git@github.com:michaelliao/learngit.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>origin  git@github.com:michaelliao/learngit.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:michaelliao/learngit.gitCloning into <span class="token string">'learngit'</span><span class="token punctuation">..</span>.remote: Counting objects: <span class="token number">40</span>, done.remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">21</span>/21<span class="token punctuation">)</span>, done.remote: Total <span class="token number">40</span> <span class="token punctuation">(</span>delta <span class="token number">14</span><span class="token punctuation">)</span>, reused <span class="token number">40</span> <span class="token punctuation">(</span>delta <span class="token number">14</span><span class="token punctuation">)</span>, pack-reused <span class="token number">0</span>Receiving objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">40</span>/40<span class="token punctuation">)</span>, done.Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">14</span>/14<span class="token punctuation">)</span>, done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> dev origin/dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> env.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add env"</span><span class="token punctuation">[</span>dev 7a5e5dd<span class="token punctuation">]</span> <span class="token function">add</span> <span class="token function">env</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> env.txt$ <span class="token function">git</span> push origin devCounting objects: <span class="token number">3</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">2</span>/2<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">3</span>/3<span class="token punctuation">)</span>, <span class="token number">308</span> bytes <span class="token operator">|</span> <span class="token number">308.00</span> KiB/s, done.Total <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git   f52c633<span class="token punctuation">..</span>7a5e5dd  dev -<span class="token operator">&gt;</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> env.txt<span class="token function">env</span>$ <span class="token function">git</span> <span class="token function">add</span> env.txt$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"add new env"</span><span class="token punctuation">[</span>dev 7bd91f1<span class="token punctuation">]</span> <span class="token function">add</span> new <span class="token function">env</span> <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode <span class="token number">100644</span> env.txt$ <span class="token function">git</span> push origin devTo github.com:michaelliao/learngit.git <span class="token operator">!</span> <span class="token punctuation">[</span>rejected<span class="token punctuation">]</span>        dev -<span class="token operator">&gt;</span> dev <span class="token punctuation">(</span>non-fast-forward<span class="token punctuation">)</span>error: failed to push some refs to <span class="token string">'git@github.com:michaelliao/learngit.git'</span>hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes <span class="token punctuation">(</span>e.g.hint: <span class="token string">'git pull ...'</span><span class="token punctuation">)</span> before pushing again.hint: See the <span class="token string">'Note about fast-forwards'</span> <span class="token keyword">in</span> <span class="token string">'git push --help'</span> <span class="token keyword">for</span> details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> pullThere is no tracking information <span class="token keyword">for</span> the current branch.Please specify <span class="token function">which</span> branch you want to merge with.See git-pull<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> details.    <span class="token function">git</span> pull <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>If you wish to <span class="token builtin class-name">set</span> tracking information <span class="token keyword">for</span> this branch you can <span class="token keyword">do</span> so with:    <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/<span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/dev devBranch <span class="token string">'dev'</span> <span class="token builtin class-name">set</span> up to track remote branch <span class="token string">'dev'</span> from <span class="token string">'origin'</span><span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再pull：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> pullAuto-merging env.txtCONFLICT <span class="token punctuation">(</span>add/add<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> env.txtAutomatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"fix env conflict"</span><span class="token punctuation">[</span>dev 57c53ab<span class="token punctuation">]</span> fix <span class="token function">env</span> conflict$ <span class="token function">git</span> push origin devCounting objects: <span class="token number">6</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">4</span>/4<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">6</span>/6<span class="token punctuation">)</span>, <span class="token number">621</span> bytes <span class="token operator">|</span> <span class="token number">621.00</span> KiB/s, done.Total <span class="token number">6</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git   7a5e5dd<span class="token punctuation">..</span>57c53ab  dev -<span class="token operator">&gt;</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><p>每次合并再push后，分支变成了这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit* d1be385 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master, origin/master<span class="token punctuation">)</span> init hello*   e5e69f1 Merge branch <span class="token string">'dev'</span><span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> *   57c53ab <span class="token punctuation">(</span>origin/dev, dev<span class="token punctuation">)</span> fix <span class="token function">env</span> conflict<span class="token operator">|</span> <span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> <span class="token operator">|</span> * 7a5e5dd <span class="token function">add</span> <span class="token function">env</span><span class="token operator">|</span> * <span class="token operator">|</span> 7bd91f1 <span class="token function">add</span> new <span class="token function">env</span><span class="token operator">|</span> <span class="token operator">|</span>/  * <span class="token operator">|</span>   12a631b merged bug fix <span class="token number">101</span><span class="token operator">|</span><span class="token punctuation">\</span> <span class="token punctuation">\</span>  <span class="token operator">|</span> * <span class="token operator">|</span> 4c805e2 fix bug <span class="token number">101</span><span class="token operator">|</span>/ /  * <span class="token operator">|</span>   e1e9c68 merge with no-ff<span class="token operator">|</span><span class="token punctuation">\</span> <span class="token punctuation">\</span>  <span class="token operator">|</span> <span class="token operator">|</span>/  <span class="token operator">|</span> * f52c633 <span class="token function">add</span> merge<span class="token operator">|</span>/  *   cf810e4 conflict fixed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p><p>其实是可以做到的！</p><p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p><img src="https://gitee.com/jgyong/blogimg/raw/master/img/202302191537137.jpeg" alt="rebase"></p><p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><pre class="line-numbers language-none"><code class="language-none">$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello*   e5e69f1 Merge branch 'dev'|\  | *   57c53ab (origin/dev, dev) fix env conflict| |\  | | * 7a5e5dd add env| * | 7bd91f1 add new env...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin masterTo github.com:michaelliao/learngit.git <span class="token operator">!</span> <span class="token punctuation">[</span>rejected<span class="token punctuation">]</span>        master -<span class="token operator">&gt;</span> master <span class="token punctuation">(</span>fetch first<span class="token punctuation">)</span>error: failed to push some refs to <span class="token string">'git@github.com:michaelliao/learngit.git'</span>hint: Updates were rejected because the remote contains work that you <span class="token keyword">do</span>hint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: <span class="token punctuation">(</span>e.g., <span class="token string">'git pull ...'</span><span class="token punctuation">)</span> before pushing again.hint: See the <span class="token string">'Note about fast-forwards'</span> <span class="token keyword">in</span> <span class="token string">'git push --help'</span> <span class="token keyword">for</span> details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> pullremote: Counting objects: <span class="token number">3</span>, done.remote: Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">1</span>/1<span class="token punctuation">)</span>, done.remote: Total <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">1</span><span class="token punctuation">)</span>, reused <span class="token number">3</span> <span class="token punctuation">(</span>delta <span class="token number">1</span><span class="token punctuation">)</span>, pack-reused <span class="token number">0</span>Unpacking objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">3</span>/3<span class="token punctuation">)</span>, done.From github.com:michaelliao/learngit   d1be385<span class="token punctuation">..</span>f005ed4  master     -<span class="token operator">&gt;</span> origin/master * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.0       -<span class="token operator">&gt;</span> v1.0Auto-merging hello.pyMerge made by the <span class="token string">'recursive'</span> strategy. hello.py <span class="token operator">|</span> <span class="token number">1</span> + <span class="token number">1</span> <span class="token function">file</span> changed, <span class="token number">1</span> insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用<code>git status</code>看看状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is ahead of <span class="token string">'origin/master'</span> by <span class="token number">3</span> commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>nothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><p>用<code>git log</code>看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit*   e0ea545 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> Merge branch <span class="token string">'master'</span> of github.com:michaelliao/learngit<span class="token operator">|</span><span class="token punctuation">\</span>  <span class="token operator">|</span> * f005ed4 <span class="token punctuation">(</span>origin/master<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> <span class="token assign-left variable">exit</span><span class="token operator">=</span><span class="token number">1</span>* <span class="token operator">|</span> 582d922 <span class="token function">add</span> author* <span class="token operator">|</span> <span class="token number">8875536</span> <span class="token function">add</span> comment<span class="token operator">|</span>/  * d1be385 init hello<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p><p>有！</p><p>什么问题？</p><p>不好看！</p><p>有没有解决方法？</p><p>有！</p><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> rebaseFirst, rewinding <span class="token function">head</span> to replay your work on <span class="token function">top</span> of it<span class="token punctuation">..</span>.Applying: <span class="token function">add</span> commentUsing index info to reconstruct a base tree<span class="token punctuation">..</span>.Mhello.pyFalling back to patching base and <span class="token number">3</span>-way merge<span class="token punctuation">..</span>.Auto-merging hello.pyApplying: <span class="token function">add</span> authorUsing index info to reconstruct a base tree<span class="token punctuation">..</span>.Mhello.pyFalling back to patching base and <span class="token number">3</span>-way merge<span class="token punctuation">..</span>.Auto-merging hello.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit* 7e61ed4 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master<span class="token punctuation">)</span> <span class="token function">add</span> author* 3611cfe <span class="token function">add</span> comment* f005ed4 <span class="token punctuation">(</span>origin/master<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> <span class="token assign-left variable">exit</span><span class="token operator">=</span><span class="token number">1</span>* d1be385 init hello<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Mac:~/learngit michael$ <span class="token function">git</span> push origin masterCounting objects: <span class="token number">6</span>, done.Delta compression using up to <span class="token number">4</span> threads.Compressing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">5</span>/5<span class="token punctuation">)</span>, done.Writing objects: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">6</span>/6<span class="token punctuation">)</span>, <span class="token number">576</span> bytes <span class="token operator">|</span> <span class="token number">576.00</span> KiB/s, done.Total <span class="token number">6</span> <span class="token punctuation">(</span>delta <span class="token number">2</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>remote: Resolving deltas: <span class="token number">100</span>% <span class="token punctuation">(</span><span class="token number">2</span>/2<span class="token punctuation">)</span>, completed with <span class="token number">1</span> <span class="token builtin class-name">local</span> object.To github.com:michaelliao/learngit.git   f005ed4<span class="token punctuation">..</span>7e61ed4  master -<span class="token operator">&gt;</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用<code>git log</code>看看效果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span> <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit* 7e61ed4 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master, origin/master<span class="token punctuation">)</span> <span class="token function">add</span> author* 3611cfe <span class="token function">add</span> comment* f005ed4 <span class="token builtin class-name">set</span> <span class="token assign-left variable">exit</span><span class="token operator">=</span><span class="token number">1</span>* d1be385 init hello<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>远程分支的提交历史也是一条直线。</p><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以用命令<code>git tag</code>查看所有标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline --abbrev-commit12a631b <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> master, tag: v1.0, origin/master<span class="token punctuation">)</span> merged bug fix <span class="token number">101</span>4c805e2 fix bug <span class="token number">101</span>e1e9c68 merge with no-fff52c633 <span class="token function">add</span> mergecf810e4 conflict fixed5dc6824 <span class="token operator">&amp;</span> simple14096d0 AND simpleb17d20e branch <span class="token builtin class-name">test</span>d46f35e remove test.txtb84166e <span class="token function">add</span> test.txt519219b <span class="token function">git</span> tracks changese43a48b understand how stage works1094adb append GPLe475afc <span class="token function">add</span> distributedeaadf4e wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag v0.9 f52c633<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用命令<code>git tag</code>查看标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tagv0.9v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 <span class="token punctuation">(</span>tag: v0.9<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:56:54 <span class="token number">2018</span> +0800    <span class="token function">add</span> merge<span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txt<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-a</span> v0.1 <span class="token parameter variable">-m</span> <span class="token string">"version 0.1 released"</span> 1094adb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> show v0.1tag v0.1Tagger: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">22</span>:48:43 <span class="token number">2018</span> +0800version <span class="token number">0.1</span> releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="token punctuation">(</span>tag: v0.1<span class="token punctuation">)</span>Author: Michael Liao <span class="token operator">&lt;</span>askxuefeng@gmail.com<span class="token operator">&gt;</span>Date:   Fri May <span class="token number">18</span> <span class="token number">21</span>:06:15 <span class="token number">2018</span> +0800    append GPL<span class="token function">diff</span> <span class="token parameter variable">--git</span> a/readme.txt b/readme.txt<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-d</span> v0.1Deleted tag <span class="token string">'v0.1'</span> <span class="token punctuation">(</span>was f15b0dd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin v1.0Total <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.0 -<span class="token operator">&gt;</span> v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin <span class="token parameter variable">--tags</span>Total <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>, reused <span class="token number">0</span> <span class="token punctuation">(</span>delta <span class="token number">0</span><span class="token punctuation">)</span>To github.com:michaelliao/learngit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v0.9 -<span class="token operator">&gt;</span> v0.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> tag <span class="token parameter variable">-d</span> v0.9Deleted tag <span class="token string">'v0.9'</span> <span class="token punctuation">(</span>was f52c633<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - <span class="token punctuation">[</span>deleted<span class="token punctuation">]</span>         v0.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h2 id="七-使用GitHub"><a href="#七-使用GitHub" class="headerlink" title="七 使用GitHub"></a>七 使用GitHub</h2><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p><p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap%EF%BC%8C%E7%82%B9%E2%80%9CFork%E2%80%9D%E5%B0%B1%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8B%E5%85%8B%E9%9A%86%E4%BA%86%E4%B8%80%E4%B8%AAbootstrap%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%EF%BC%8C%E4%BB%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8Bclone%EF%BC%9A">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p><pre class="line-numbers language-none"><code class="language-none">git clone git@github.com:michaelliao/bootstrap.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">┌─ GitHub ────────────────────────────────────┐│                                             ││ ┌─────────────────┐     ┌─────────────────┐ ││ │ twbs/bootstrap  │────&gt;│  my/bootstrap   │ ││ └─────────────────┘     └─────────────────┘ ││                                  ▲          │└──────────────────────────────────┼──────────┘                                   ▼                          ┌─────────────────┐                          │ local/bootstrap │                          └─────────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%60your-github-id.txt%60%E7%9A%84%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%99%E7%82%B9%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0Git%E7%9A%84%E5%BF%83%E5%BE%97%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8E%A8%E9%80%81%E4%B8%80%E4%B8%AApull">https://github.com/michaelliao/learngit，创建一个`your-github-id.txt`的文本文件，写点自己学习Git的心得，然后推送一个pull</a> request给我，我会视心情而定是否接受。</p><hr><h2 id="八-总结"><a href="#八-总结" class="headerlink" title="八 总结"></a>八 总结</h2><h3 id="1-常规步骤"><a href="#1-常规步骤" class="headerlink" title="1. 常规步骤:"></a>1. 常规步骤:</h3><ol><li><p>创建本地仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>远程仓库</p><ol><li>关联版本库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin  git@gitee.com:gyjiang/NS3LoadBalance.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>将本地仓库添加至暂存区</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>推送</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">   <span class="token function">git</span> push <span class="token parameter variable">-u</span> origin master<span class="token operator">!</span><span class="token punctuation">[</span>git<span class="token punctuation">]</span><span class="token punctuation">(</span>https://gitee.com/jgyong/blogimg/raw/master/img/202302191537138.png<span class="token punctuation">)</span><span class="token comment">### 2 便捷方式</span><span class="token number">1</span>.    将add与commit合并<span class="token punctuation">[</span>^2<span class="token punctuation">]</span>一般流程```bash<span class="token function">git</span> <span class="token function">add</span> <span class="token operator">&lt;</span>file<span class="token operator">&gt;</span> <span class="token comment"># 将文件添加到暂存区</span><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"Commit Message"</span> <span class="token comment"># 将暂存区的文件提交到本地仓库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>合并语句</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">-am</span> <span class="token string">"Commit Message"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="九-出现的问题以及解决方法"><a href="#九-出现的问题以及解决方法" class="headerlink" title="九 出现的问题以及解决方法"></a>九 出现的问题以及解决方法</h2><h3 id="1-“ssh-connect-to-host-github-com-port-22-Connection-timed-out”"><a href="#1-“ssh-connect-to-host-github-com-port-22-Connection-timed-out”" class="headerlink" title="1 “ssh:connect to host github.com port 22: Connection timed out”"></a>1 “ssh:connect to host github.com port 22: Connection timed out”</h3><p>方法思路：更换端口（参考[^1]）</p><ol><li><p>进入~/.ssh</p></li><li><p>修改config文件</p></li><li><p>编辑文件内容</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gitlab.comHostname altssh.gitlab.comUser gitPort 443PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>保存退出</p></li><li><p>检查是否成功</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[^1]:<a href="https://blog.csdn.net/weixin_45637036/article/details/106560217">Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</a><br>[^2]: <a href="https://geek-docs.com/git/git-questions/466_git_git_add_and_commit_in_one_command.html">Git 如何在Git中使用一条命令同时进行add和commit操作</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UCOM会议</title>
      <link href="/2023/07/13/ucom-hui-yi/"/>
      <url>/2023/07/13/ucom-hui-yi/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/07/13/ucom-hui-yi/1111.png" alt="会议合影"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2023/07/04/bo-ke/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2023/07/04/bo-ke/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<p>博客搭建成功！！！</p>]]></content>
      
      
      <categories>
          
          <category> 心路历程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
